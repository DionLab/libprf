#include "prf_config.h"
#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>
#include <pthread.h>
#include <assert.h>
#define __USE_INLINE_FUNCTIONS__
#include "pfProfile.h"
#include "pfSequence.h"
#include "pfOutput.h"
#include "FASTA_threads.h"

#define HEADER_STACK_SIZE 256
#define SUCCESS 0

/****************************************************************************************************
 * From the following enums, we define the ordering as follow
 * 
enum SearchType { PRF=1, REGEX=2 };
enum OutputType { TEXT, HISTOGRAM, DENSITY, PNG, DATA, PDF };
enum Constrain { WITH_REVERSE=1, SCORE_RANGE=2, CYCLE_RANGE=4, INVERSE_SELECTION=8, BORDER_CLIP=16};
enum WrapperRange { Wrapper_Alignement = 0, Wrapper_Source = 1, Wrapper_Before = 2, Wrapper_After = 3,
	                  Wrapper_Outer = 4};

	MATRIX PRF:
		TEXT:																								: 160 cases
			- WITH_REVERSE
			- SCORE_RANGE
			- CYCLE_RANGE if circular profile only
			- INVERSE_SELECTION
			- BORDER_CLIP
			- WRAPPER (5 cases)
			
		TEXT2_OPTIMAL_WITH_REVERSE:													:  16 cases		
			- SCORE_RANGE
			- CYCLE_RANGE if circular profile only
			- INVERSE_SELECTION
			- BORDER_CLIP
			
		HISTOGRAM:																					:  16 cases
			- WITH_REVERSE
			- SCORE_RANGE 
			- CYCLE_RANGE if circular profile only
			- BORDER_CLIP
			- HISTO_CYCLE
			
		DENSITY: if circular profile												:  2 cases
			- WITH_REVERSE
			- SCORE_RANGE required anyway
			- CYCLE_RANGE required anyway
	
		PDF, PNG, DATA:																			: 2 cases
			- WITH_REVERSE
	
	
	REGEX or PATTERN PRF:
		TEXT:																								: 32 cases
			- WITH_REVERSE
			- SCORE_RANGE
			- CYCLE_RANGE
			- INVERSE_SELECTION
			- BORDER_CLIP
		
		HISTOGRAM:																					:  6 cases
			- WITH_REVERSE
			- SCORE_RANGE 
			- CYCLE_RANGE if circular profile only
			
		DENSITY:																						:  2 cases
			- WITH_REVERSE
			- SCORE_RANGE required anyway
			- CYCLE_RANGE required anyway
*****************************************************************************************************/

$range WITH_REVERSE 0..1
$range SCORE_RANGE 0..1
$range CYCLE_RANGE 0..1
$range HISTO_CYCLE 0..1
$range INVERSE_SELECTION 0..1
$range BORDER_CLIP 0..1
$range WRAPPER_TEXT 0..5

/****************************************************************************************************
 * External dependencies
 */
extern int compareAlignments(const void *a, const void *b);

/****************************************************************************************************
 * MATRIX PROFILES: TEXT
 */

$for WRAPPER_TEXT [[
$for BORDER_CLIP [[ $for INVERSE_SELECTION [[ $for CYCLE_RANGE [[ $for SCORE_RANGE [[ $for WITH_REVERSE [[
$if ((WRAPPER_TEXT < 5) | WITH_REVERSE) [[ 

static
THREADPOOL_FUNCTION(tpfaps$WRAPPER_TEXT$BORDER_CLIP$INVERSE_SELECTION$CYCLE_RANGE$SCORE_RANGE$WITH_REVERSE)
$if (CYCLE_RANGE == 1) [[

#ifdef PRF_CORE_REPEAT

]]
{
		int res = SUCCESS;
		$if (WRAPPER_TEXT == 1) [[ ]] $elif (WRAPPER_TEXT == 4) [[
			char NewHeader[1024]; 
		]]
		$else [[ 
			char NewHeader[HEADER_STACK_SIZE]; 
		]]
		$if WITH_REVERSE [[
			unsigned char RevComp_Index_Mapping[ALPHABET_SIZE+2] __attribute__((aligned(16)));
		]]
// 	  printf("Thread started fct THREAD_FCT_NAME\n");
		
		/*************************************************************************/
		/*                          GET COMMON DATA                              */
		/*************************************************************************/
		common_t * const common = _Data->common;
		
		/* For profile search we need to have */
		const struct Profile * const restrict prf = common->profile;
		const Compute_t * const restrict CoreCompute =common->Compute;
		
		/* For output we need */
		const OutputType_t * const restrict OutputType = common->OutputType;
		pthread_mutex_t * const restrict PrintLock = &(common->PrintLock);
		
		/*************************************************************************/
		/*                          ALLOCATE MEMORY                              */
		/*************************************************************************/
		const size_t prfLength = prf->Length;
		const size_t matrixLD  = prf->Length + 1;
		size_t LargestSequence = 2048;
		union lScores * restrict matrix = _mm_malloc(matrixLD*LargestSequence*sizeof(union lScores), 64);
		$if WITH_REVERSE [[
			union lScores * restrict rvmatrix = _mm_malloc(matrixLD*LargestSequence*sizeof(union lScores), 64);
		]]
		unsigned char * restrict SequenceText = malloc(LargestSequence*sizeof(unsigned char));
		int * restrict WORK          = _mm_malloc(GetWorkArraySize(prf, CoreCompute),64);
		if ( $if WITH_REVERSE [[ rvmatrix == NULL || ]] matrix == NULL || WORK == NULL || SequenceText == NULL ) {
			res = -1; 
			goto FIN;
		}
		$if (WRAPPER_TEXT == 1) [[ ]] $else [[
		_Bool * restrict HasAPath;
		/*if (!(OutputType->Specific.Text.OptimalOnly)) */{
			HasAPath = (_Bool*) malloc(LargestSequence*sizeof(_Bool));
			if (HasAPath == NULL) {
				res = -1;
				goto FIN;
			}
		}
		]]
		$if ( (WRAPPER_TEXT == 0) | (WRAPPER_TEXT == 2) | (WRAPPER_TEXT == 3) | (WRAPPER_TEXT == 5))  [[
			size_t OutputSequenceMemorySize = 0UL;
			unsigned char * restrict OutputSequence = NULL;
		]] $elif (WRAPPER_TEXT == 4) [[
			size_t AlignmentsMemorySize = 10;
			Alignment_t * Alignments = (Alignment_t*) malloc(AlignmentsMemorySize*sizeof(Alignment_t));
			if (Alignments == NULL) {
				fprintf(stderr, "Unable to increase alignments'size to %lu\n", AlignmentsMemorySize);
				pthread_exit((void*) 1);
			}
		]]
		$if (WRAPPER_TEXT == 4) [[ 
			unsigned char * restrict BackupSequence = malloc(LargestSequence*sizeof(unsigned char)); 
			if (BackupSequence == NULL) {
				res = -1;
				goto FIN;
			}
		]]
		
		/*************************************************************************/
		/*                          CONFIGURE WORKER                             */
		/*************************************************************************/
		$if WITH_REVERSE [[
			for (unsigned char a=0;a<ALPHABET_SIZE+2; a++) RevComp_Index_Mapping[a] = a;
			{
				unsigned char c;
				c = RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'A' - (int) 'A' ] ];
				RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'A' - (int) 'A' ] ] = RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'T' - (int) 'A' ] ];
				RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'T' - (int) 'A' ] ] = c;
			}
			{
				unsigned char c;
				c = RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'C' - (int) 'A' ] ];
				RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'C' - (int) 'A' ] ] = RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'G' - (int) 'A' ] ];
				RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'G' - (int) 'A' ] ] = c;
			}
		]]

    /* Assure all threads have been created before starting serving */
    threadpool_t* const restrict  thpool = _Data->thpool;
   
//		/* Register signal handler */
//     struct sigaction act;
//     act.sa_handler = thread_hold;
//     if (sigaction(SIGUSR1, &act, NULL) == -1) {
// 	    fprintf(stderr, "thread_do(): cannot handle SIGUSR1");
//     }
    
    /* Mark thread as alive (initialized) */
    pthread_mutex_lock(&thpool->thcount_lock);
    thpool->num_threads_alive += 1;
    pthread_mutex_unlock(&thpool->thcount_lock);
    
    // Initialize some other data
    fasta_job_t * task = NULL;
		
    const int CutOff = prf->CutOff;
		unsigned int AlignedSeqCounter = 0U;
		
		while(thpool->threads_keepalive) {
			bsem_wait(thpool->jobqueue_p.has_items);
			
			if (thpool->threads_keepalive){
				pthread_mutex_lock(&thpool->thcount_lock);
				thpool->num_threads_working++;
				pthread_mutex_unlock(&thpool->thcount_lock);
				
				/* Read job from queue and execute it */
				pthread_mutex_lock(&thpool->jobqueue_p.rwmutex);
				task = (fasta_job_t*) jobqueue_pull(&thpool->jobqueue_p);
				pthread_mutex_unlock(&thpool->jobqueue_p.rwmutex);
				
				/***************************************************************/
				/*                     START THE TASK                          */
				/***************************************************************/
				if (task) {
					/* Transform into real Fasta sequence and split header and data */
					Sequence_t SeqData = task->Fasta_Sequence;
					if (SeqData.ProfileData.Length > 0UL) {
						size_t SeqLength = 0UL;
						{
							unsigned char * restrict ptr = SeqData.ProfileData.ProfileIndex;
							const unsigned char * const limit = ptr + SeqData.ProfileData.Length; 
							while ( ptr < limit) {
								register unsigned char c = *ptr++;
								c = (c >= 'a') ? c - ('a' - 'A') : c;
								if (c >= 'A' && c <= 'Z') 
									SeqData.ProfileData.ProfileIndex[SeqLength++] = c;
							}
							SeqData.ProfileData.Length = SeqLength;
						}
						
						/* Check memory allocated size */
						if (SeqLength >= LargestSequence) {
							LargestSequence = (SeqLength + 1UL + 2047UL) & ~(2047UL);
							_mm_free(matrix);
							$if WITH_REVERSE [[ _mm_free(rvmatrix); ]]
							free(SequenceText);
							matrix = _mm_malloc(matrixLD*LargestSequence*sizeof(union lScores), 64);
							$if WITH_REVERSE [[
								rvmatrix = _mm_malloc(matrixLD*LargestSequence*sizeof(union lScores), 64);
							]]
							SequenceText = malloc(LargestSequence*sizeof(unsigned char));
							if ( $if WITH_REVERSE [[rvmatrix == NULL ||]] matrix == NULL || SequenceText == NULL) {
								res = -1; 
								goto FIN;
							}
							$if (WRAPPER_TEXT == 1) [[ ]] $else [[
								if (!(OutputType->Specific.Text.OptimalOnly)) {
									HasAPath = realloc(HasAPath, LargestSequence*sizeof(_Bool));
									if (HasAPath == NULL) {
										res = -1;
										goto FIN;
									}
								}
								$if (WRAPPER_TEXT == 4) [[ 
									BackupSequence = realloc(BackupSequence, LargestSequence*sizeof(unsigned char)); 
									if (BackupSequence == NULL) {
										res = -1;
										goto FIN;
									}
								]]
							]]
						}
						memcpy(SequenceText, SeqData.ProfileData.ProfileIndex, SeqLength); SequenceText[SeqLength] = '\0';
												
						/* Translate first sequence */
						PFSequence * restrict PFSeq = TranslateSequenceToIndex(&(SeqData.ProfileData), prf->Alphabet_Mapping);
						CoreCompute->BuildMatrix(prf, PFSeq->ProfileIndex, matrix, WORK, NULL, 0, SeqLength);
						
						$if WITH_REVERSE [[
							RevCompIndex(PFSeq, RevComp_Index_Mapping);
							CoreCompute->BuildMatrix(prf, PFSeq->ProfileIndex, rvmatrix, WORK, NULL, 0, SeqLength);
						]]
						
						///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
						// ALIGNMENT, SOURCE BEFORE AND AFTER OUTPUT
						$if ( (WRAPPER_TEXT == 0) | (WRAPPER_TEXT == 2) | (WRAPPER_TEXT == 3)) [[ {
							Alignment_t Alignment;
							unsigned int count = 1U;
							memset(HasAPath, 0, (1+SeqLength));
							do {
								/* Get Best Alignment */
								size_t OutputSequenceLength = CoreCompute->GetNextBestAlignment(matrix, HasAPath, &Alignment, SeqLength, prfLength);
								if (OutputSequenceLength == 0 && Alignment.Score >= prf->CutOff) {
									fprintf(stderr, "Issue as alignment does not start with an ENTRY point! (score=%i, seqlength=%lu)\n%s\n",
													Alignment.Score, SeqLength, SequenceText);
									break;
								}
								
								/* Prevent further alignment to use this region */
								_Bool AlreadyUsed = false;
								assert(Alignment.Matrix.row.End <= SeqLength);
								assert(Alignment.Matrix.row.Begin >=0);
								for(int k=Alignment.Matrix.row.Begin; k<=Alignment.Matrix.row.End; ++k) {
									AlreadyUsed |= HasAPath[k]; 
									HasAPath[k] = true;
								}
									
								if (!AlreadyUsed) {
									_Bool KeepIt = true;
									$if SCORE_RANGE [[
										KeepIt &= (Alignment.Score >= OutputType->ScoreRange[0] && Alignment.Score <= OutputType->ScoreRange[1]);
									]]
									$if CYCLE_RANGE [[ 
										KeepIt &= (Alignment.Cycles >= OutputType->CycleRange[0] && Alignment.Cycles <= OutputType->CycleRange[1]);
									]]
									$if BORDER_CLIP [[
										KeepIt &= Alignment.Region.sequence.Begin >= OutputType->BorderClip[0]
													&& ((Alignment.Region.sequence.End + OutputType->BorderClip[1]) <= SeqLength);
									]]
									
									$if INVERSE_SELECTION [[
										KeepIt = !KeepIt;
									]]
									$if (BORDER_CLIP | SCORE_RANGE | CYCLE_RANGE | INVERSE_SELECTION) [[
										if (KeepIt)
									]] $else [[
										if ((Alignment.Score >= prf->CutOff || OutputType->Specific.Text.OptimalOnly) )
									]]
									{
										$if (WRAPPER_TEXT == 0) [[
											/* Get Aligned Sequence */
											if (OutputSequenceLength > OutputSequenceMemorySize) {
												OutputSequenceMemorySize = OutputSequenceLength; 
												OutputSequence = (unsigned char*) realloc(OutputSequence, OutputSequenceMemorySize*sizeof(unsigned char));
												if (OutputSequence == NULL) {
													fputs("Unable to allocate memory\n", stderr);
													exit(1);
												}
											}
									
											CoreCompute->GetAlignmentSequence(matrix, SequenceText, OutputSequence, &Alignment, OutputSequenceMemorySize, prfLength);
										]]
										$elif (WRAPPER_TEXT == 2) [[
											OutputSequence = SequenceText;
											OutputSequenceLength = Alignment.Region.sequence.Begin - 1;
										]]
										$elif (WRAPPER_TEXT == 3) [[
											OutputSequence = SequenceText + Alignment.Region.sequence.End + 1;
											OutputSequenceLength = SeqLength - Alignment.Region.sequence.End;
										]]
										
										snprintf(NewHeader, HEADER_STACK_SIZE, "%s/%u", SeqData.Data.Header, count++);
										pthread_mutex_lock(PrintLock);
										OutputType->Specific.Text.Print(prf,
																										OutputSequence,
																										&Alignment, NewHeader, OutputSequenceLength, 0.0f);
										pthread_mutex_unlock(PrintLock);
										$if (BORDER_CLIP | SCORE_RANGE | CYCLE_RANGE | INVERSE_SELECTION) [[
											if (OutputType->Specific.Text.OptimalOnly) break;
										]]
									}
								}
								$if (BORDER_CLIP | SCORE_RANGE | CYCLE_RANGE) [[ ]] $else [[
									if (OutputType->Specific.Text.OptimalOnly) break;
								]]
							} while ($if SCORE_RANGE [[ Alignment.Score >= OutputType->ScoreRange[0] ]] $else [[ Alignment.Score >= prf->CutOff ]] );
							
							$if WITH_REVERSE [[
								memset(HasAPath, 0, (1+SeqLength));
								PerformRevComp(SequenceText, SeqLength);
								do {
								/* Get Best Alignment */
								size_t OutputSequenceLength = CoreCompute->GetNextBestAlignment(rvmatrix, HasAPath, &Alignment, SeqLength, prfLength);
								if (OutputSequenceLength == 0 && Alignment.Score >= prf->CutOff) {
									fprintf(stderr, "Issue as alignment does not start with an ENTRY point! (score=%i, seqlength=%lu)\n%s\n",
													Alignment.Score, SeqLength, SequenceText);
									break;
								}
								
								/* Prevent further alignment to use this region */
								_Bool AlreadyUsed = false;
								assert(Alignment.Matrix.row.End <= SeqLength);
								assert(Alignment.Matrix.row.Begin >=0);
								for(int k=Alignment.Matrix.row.Begin; k<=Alignment.Matrix.row.End; ++k) {
									AlreadyUsed |= HasAPath[k]; 
									HasAPath[k] = true;
								}
									
								if (!AlreadyUsed) {
									_Bool KeepIt = true;
									$if SCORE_RANGE [[
										KeepIt &= (Alignment.Score >= OutputType->ScoreRange[0] && Alignment.Score <= OutputType->ScoreRange[1]);
									]]
									$if CYCLE_RANGE [[ 
										KeepIt &= (Alignment.Cycles >= OutputType->CycleRange[0] && Alignment.Cycles <= OutputType->CycleRange[1]);
									]]
									$if BORDER_CLIP [[
										KeepIt &= Alignment.Region.sequence.Begin >= OutputType->BorderClip[0]
													&& ((Alignment.Region.sequence.End + OutputType->BorderClip[1]) <= SeqLength);
									]]
									
									$if INVERSE_SELECTION [[
										KeepIt = !KeepIt;
									]]
									$if (BORDER_CLIP | SCORE_RANGE | CYCLE_RANGE | INVERSE_SELECTION) [[
										if (KeepIt)
									]] $else [[
										if ((Alignment.Score >= prf->CutOff || OutputType->Specific.Text.OptimalOnly) )
									]]
									{
										$if (WRAPPER_TEXT == 0) [[
											/* Get Aligned Sequence */
											if (OutputSequenceLength > OutputSequenceMemorySize) {
												OutputSequenceMemorySize = OutputSequenceLength; 
												OutputSequence = (unsigned char*) realloc(OutputSequence, OutputSequenceMemorySize*sizeof(unsigned char));
												if (OutputSequence == NULL) {
													fputs("Unable to allocate memory\n", stderr);
													exit(1);
												}
											}
									
											CoreCompute->GetAlignmentSequence(rvmatrix, SequenceText, OutputSequence, &Alignment, OutputSequenceMemorySize, prfLength);
										]]
										$elif (WRAPPER_TEXT == 2) [[
											OutputSequence = SequenceText;
											OutputSequenceLength = Alignment.Region.sequence.Begin - 1;
										]]
										$elif (WRAPPER_TEXT == 3) [[
											OutputSequence = SequenceText + Alignment.Region.sequence.End + 1;
											OutputSequenceLength = SeqLength - Alignment.Region.sequence.End;
										]]
										
										snprintf(NewHeader, HEADER_STACK_SIZE, "%s/%u", SeqData.Data.Header, count++);
										pthread_mutex_lock(PrintLock);
										OutputType->Specific.Text.Print(prf,
																										OutputSequence,
																										&Alignment, NewHeader, OutputSequenceLength, 0.0f);
										pthread_mutex_unlock(PrintLock);
										$if (BORDER_CLIP | SCORE_RANGE | CYCLE_RANGE | INVERSE_SELECTION) [[
											if (OutputType->Specific.Text.OptimalOnly) break;
										]]
									}
								}
								$if (BORDER_CLIP | SCORE_RANGE | CYCLE_RANGE) [[ ]] $else [[
									if (OutputType->Specific.Text.OptimalOnly) break;
								]]
							}  while ($if SCORE_RANGE [[ Alignment.Score >= OutputType->ScoreRange[0] ]] $else [[ Alignment.Score >= prf->CutOff ]] );
							]]
						} ]]
						$elif (WRAPPER_TEXT == 4) [[ {
							///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							// IN_BETWEEN OUTPUT
							unsigned int count = 0U;
							memset(HasAPath, 0, (1+SeqLength));
							Alignment_t * restrict Alignment;
							do {
								Alignment = &Alignments[count];
								/* Get Best Alignment */
								size_t OutputSequenceLength = CoreCompute->GetNextBestAlignment(matrix, HasAPath, Alignment, SeqLength, prfLength);
								if (OutputSequenceLength == 0 && Alignment->Score >= prf->CutOff) {
									fprintf(stderr, "Issue as alignment does not start with an ENTRY point! (score=%i, seqlength=%lu)\n%s\n",
													Alignment->Score, SeqLength, SequenceText);
									break;
								}
								
								/* Prevent further alignment to use this region */
								_Bool AlreadyUsed = false;
								assert(Alignment->Matrix.row.End <= SeqLength);
								assert(Alignment->Matrix.row.Begin >=0);
								for(int k=Alignment->Matrix.row.Begin; k<=Alignment->Matrix.row.End; ++k) {
									AlreadyUsed |= HasAPath[k]; 
									HasAPath[k] = true;
								}
									
								if (!AlreadyUsed) {
									_Bool KeepIt = true;
									$if SCORE_RANGE [[
										KeepIt &= (Alignment->Score >= OutputType->ScoreRange[0] && Alignment->Score <= OutputType->ScoreRange[1]);
									]]
									$if CYCLE_RANGE [[ 
										KeepIt &= (Alignment->Cycles >= OutputType->CycleRange[0] && Alignment->Cycles <= OutputType->CycleRange[1]);
									]]
									$if BORDER_CLIP [[
										KeepIt &= Alignment->Region.sequence.Begin >= OutputType->BorderClip[0]
													&& ((Alignment->Region.sequence.End + OutputType->BorderClip[1]) <= SeqLength);
									]]
									
									$if INVERSE_SELECTION [[
										KeepIt = !KeepIt;
									]]
									$if (BORDER_CLIP | SCORE_RANGE | CYCLE_RANGE | INVERSE_SELECTION) [[
										if (KeepIt)
									]] $else [[
										if ((Alignment->Score >= prf->CutOff || OutputType->Specific.Text.OptimalOnly) )
									]]
									{
										if (++count >= AlignmentsMemorySize) {
											AlignmentsMemorySize += 10;
											Alignments = (Alignment_t*) realloc(Alignments, AlignmentsMemorySize*sizeof(Alignment_t));
											if (Alignments == NULL) {
												fprintf(stderr, "Unable to increase alignments'size to %lu\n", AlignmentsMemorySize);
												pthread_exit((void*) 1);
											}
											Alignment = &Alignments[count-1];
										}
									}
								}
							}  while ($if SCORE_RANGE [[ OutputType->ScoreRange[0] ]] $else [[ Alignment->Score >= prf->CutOff ]] );
							
							$if WITH_REVERSE [[
								memset(HasAPath, 0, (1+SeqLength));
								memcpy(BackupSequence, SequenceText, SeqLength);
								PerformRevComp(BackupSequence, SeqLength);
								do {
									Alignment = &Alignments[count];
									/* Get Best Alignment */
									size_t OutputSequenceLength = CoreCompute->GetNextBestAlignment(rvmatrix, HasAPath, Alignment, SeqLength, prfLength);
									if (OutputSequenceLength == 0 && Alignment->Score >= prf->CutOff) {
										fprintf(stderr, "Issue as alignment does not start with an ENTRY point! (score=%i, seqlength=%lu)\n%s\n",
														Alignment->Score, SeqLength, SequenceText);
										break;
									}
									
									/* Prevent further alignment to use this region */
									_Bool AlreadyUsed = false;
									assert(Alignment->Matrix.row.End <= SeqLength);
									assert(Alignment->Matrix.row.Begin >=0);
									for(int k=Alignment->Matrix.row.Begin; k<=Alignment->Matrix.row.End; ++k) {
										AlreadyUsed |= HasAPath[k]; 
										HasAPath[k] = true;
									}
										
									if (!AlreadyUsed) {
										_Bool KeepIt = true;
										$if SCORE_RANGE [[
											KeepIt &= (Alignment->Score >= OutputType->ScoreRange[0] && Alignment->Score <= OutputType->ScoreRange[1]);
										]]
										$if CYCLE_RANGE [[ 
											KeepIt &= (Alignment->Cycles >= OutputType->CycleRange[0] && Alignment->Cycles <= OutputType->CycleRange[1]);
										]]
										$if BORDER_CLIP [[
											KeepIt &= Alignment->Region.sequence.Begin >= OutputType->BorderClip[0]
														&& ((Alignment->Region.sequence.End + OutputType->BorderClip[1]) <= SeqLength);
										]]
										
										$if INVERSE_SELECTION [[
											KeepIt = !KeepIt;
										]]
										$if (BORDER_CLIP | SCORE_RANGE | CYCLE_RANGE | INVERSE_SELECTION) [[
											if (KeepIt)
										]] $else [[
											if ((Alignment->Score >= prf->CutOff || OutputType->Specific.Text.OptimalOnly) )
										]]
										{
											if (++count >= AlignmentsMemorySize) {
												AlignmentsMemorySize += 10;
												Alignments = (Alignment_t*) realloc(Alignments, AlignmentsMemorySize*sizeof(Alignment_t));
												if (Alignments == NULL) {
													fprintf(stderr, "Unable to increase alignments'size to %lu\n", AlignmentsMemorySize);
													pthread_exit((void*) 1);
												}
												Alignment = &Alignments[count-1];
											}
										}
									}
								}  while ($if SCORE_RANGE [[ Alignment->Score >= OutputType->ScoreRange[0] ]] $else [[ Alignment->Score >= prf->CutOff ]] );
							]]
							
							/* Sort the Alignments */
							if (count) {
								qsort(Alignments, count, sizeof(Alignment_t), compareAlignments);
								{
									const size_t ThisSeqLength = Alignments[0].Region.sequence.Begin;
									if (ThisSeqLength > 0UL) {
										const unsigned char Backup = SequenceText[ThisSeqLength];
										SequenceText[ThisSeqLength] = '\0';
										const unsigned char * const AlignedSequence = SequenceText;// - 1;
										snprintf(NewHeader, 1024, "%s before %s with score %i", SeqData.Data.Header, prf->Identification, Alignments[0].Score);
										pthread_mutex_lock(PrintLock);
										OutputType->Specific.Text.Print(prf, AlignedSequence, &Alignments[0], NewHeader, ThisSeqLength, 0.0f);
										pthread_mutex_unlock(PrintLock);
										SequenceText[ThisSeqLength] = Backup;
									}
								}
								if (count >= 2) {
									for (unsigned int k=1; k<count; k++) { 
										const ssize_t ThisSeqLength = (ssize_t) Alignments[k].Region.sequence.Begin - (ssize_t) Alignments[k-1].Region.sequence.End - 1;
										if (ThisSeqLength > 0) {
											const unsigned char Backup = SequenceText[Alignments[k].Region.sequence.Begin];
											SequenceText[Alignments[k].Region.sequence.Begin] = '\0';
											const unsigned char * const AlignedSequence = SequenceText + Alignments[k-1].Region.sequence.End + 1;
											snprintf(NewHeader, 1024, "%s/%u/%u-%u in between %s with scores %i and %i", SeqData.Data.Header, k,
															Alignments[k-1].Region.sequence.End + 1, Alignments[k].Region.sequence.Begin - 1,
															prf->Identification, Alignments[k-1].Score, Alignments[k].Score);
											pthread_mutex_lock(PrintLock);
											OutputType->Specific.Text.Print(prf, AlignedSequence, &Alignments[k], NewHeader, (size_t) ThisSeqLength, 0.0f);
											pthread_mutex_unlock(PrintLock);
											SequenceText[Alignments[k].Region.sequence.Begin] = Backup;
										}
									}
								}
								{
									const ssize_t ThisSeqLength = (ssize_t) SeqLength - (ssize_t) Alignments[count-1].Region.sequence.End - 1;
									if (ThisSeqLength > 0L) {
										const unsigned char * const AlignedSequence = SequenceText + Alignments[count-1].Region.sequence.End + 1;
										snprintf(NewHeader, 1024, "%s after %s with score %i", SeqData.Data.Header, prf->Identification, Alignments[count-1].Score);
										pthread_mutex_lock(PrintLock);
										OutputType->Specific.Text.Print(prf, AlignedSequence, &Alignments[count-1], NewHeader, (size_t) ThisSeqLength, 0.0f);
										pthread_mutex_unlock(PrintLock);
									}
								}
							}
						} ]]
						$elif (WRAPPER_TEXT == 1) [[ {
							///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							// SOURCE OUTPUT
							Alignment_t Alignment;
							const Alignment_t * restrict AlignPtr = &Alignment;
							/* Get Best Alignment */
							const size_t OutputSequenceLength = CoreCompute->GetBestAlignment(matrix, &Alignment, SeqLength, prfLength);
							if (OutputSequenceLength == 0  && Alignment.Score >= prf->CutOff) {
								fprintf(stderr, "Issue as alignment does not start with an ENTRY point! (score=%i, seqlength=%lu)\n%s\n",
												Alignment.Score, SeqLength,  SequenceText);
							}
							$if WITH_REVERSE [[
								Alignment_t rvAlignment;
								/* Get Best Alignment */
								const size_t rvOutputSequenceLength = CoreCompute->GetBestAlignment(rvmatrix, &rvAlignment, SeqLength, prfLength);
								if (rvOutputSequenceLength == 0  && rvAlignment.Score >= prf->CutOff) {
									fprintf(stderr, "Issue as alignment does not start with an ENTRY point! (score=%i, seqlength=%lu)\n%s\n",
													rvAlignment.Score, SeqLength, SequenceText);
								}
								else {
									if (rvAlignment.Score > Alignment.Score) AlignPtr = &rvAlignment;
								}
							]]
							_Bool KeepIt = true;
							$if SCORE_RANGE [[
								KeepIt &= (Alignment.Score >= OutputType->ScoreRange[0] && Alignment.Score <= OutputType->ScoreRange[1]);
							]]
							$if CYCLE_RANGE [[ 
								KeepIt &= (Alignment.Cycles >= OutputType->CycleRange[0] && Alignment.Cycles <= OutputType->CycleRange[1]);
							]]
							$if BORDER_CLIP [[
								KeepIt &= Alignment.Region.sequence.Begin >= OutputType->BorderClip[0]
												&& ((Alignment.Region.sequence.End + OutputType->BorderClip[1]) <= SeqLength);
							]]
							
							$if INVERSE_SELECTION [[
								KeepIt = !KeepIt;
							]]
							$if (BORDER_CLIP | SCORE_RANGE | CYCLE_RANGE | INVERSE_SELECTION) [[
								if (KeepIt)
							]] $else [[
								if (Alignment.Score >= prf->CutOff)
							]]
							{
								pthread_mutex_lock(PrintLock);
								OutputType->Specific.Text.Print(prf, SequenceText, AlignPtr, SeqData.Data.Header, SeqLength, 0.0f );
								pthread_mutex_unlock(PrintLock);
							}
						} ]]
						$elif (WRAPPER_TEXT == 5) [[ {
							///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							// SOURCE OUTPUT
							Alignment_t Alignment;
							Alignment.Orientation = 1;
							const Alignment_t * restrict AlignPtr = &Alignment;
							const union lScores * restrict matrixPtr = matrix;
							/* Get Best Alignment */
							size_t OutputSequenceLength = CoreCompute->GetBestAlignment(matrix, &Alignment, SeqLength, prfLength);
							
							if (OutputSequenceLength == 0  && Alignment.Score >= prf->CutOff) {
								fprintf(stderr, "Issue as alignment does not start with an ENTRY point! (score=%i, seqlength=%lu)\n%s\n",
												Alignment.Score, SeqLength,  SequenceText);
							}
							Alignment_t rvAlignment;
							rvAlignment.Orientation = -1;
							/* Get Best Alignment */
							const size_t rvOutputSequenceLength = CoreCompute->GetBestAlignment(rvmatrix, &rvAlignment, SeqLength, prfLength);
							if (rvOutputSequenceLength == 0  && rvAlignment.Score >= prf->CutOff) {
								fprintf(stderr, "Issue as alignment does not start with an ENTRY point! (score=%i, seqlength=%lu)\n%s\n",
												rvAlignment.Score, SeqLength, SequenceText);
							}
							else {
								if (rvAlignment.Score > Alignment.Score) {
									AlignPtr = &rvAlignment;
									OutputSequenceLength = rvOutputSequenceLength;
									matrixPtr = rvmatrix;
								}
							}
							
							_Bool KeepIt = true;
							$if SCORE_RANGE [[
								KeepIt &= (Alignment.Score >= OutputType->ScoreRange[0] && Alignment.Score <= OutputType->ScoreRange[1]);
							]]
							$if CYCLE_RANGE [[ 
								KeepIt &= (Alignment.Cycles >= OutputType->CycleRange[0] && Alignment.Cycles <= OutputType->CycleRange[1]);
							]]
							$if BORDER_CLIP [[
								KeepIt &= Alignment.Region.sequence.Begin >= OutputType->BorderClip[0]
												&& ((Alignment.Region.sequence.End + OutputType->BorderClip[1]) <= SeqLength);
							]]
							
							$if INVERSE_SELECTION [[
								KeepIt = !KeepIt;
							]]
							
							if (KeepIt) {
								if (AlignPtr->Orientation < 0) {
									PerformRevComp(SequenceText, SeqLength);
								}
								/* Get Aligned Sequence */
								if (OutputSequenceLength > OutputSequenceMemorySize) {
									OutputSequenceMemorySize = OutputSequenceLength; 
									OutputSequence = (unsigned char*) realloc(OutputSequence, OutputSequenceMemorySize*sizeof(unsigned char));
									if (OutputSequence == NULL) {
										fputs("Unable to allocate memory\n", stderr);
										exit(1);
									}
								}
								
								CoreCompute->GetAlignmentSequence(matrixPtr, SequenceText, OutputSequence, AlignPtr, OutputSequenceMemorySize, prfLength);
								
								pthread_mutex_lock(PrintLock);
								OutputType->Specific.Text.Print(prf, OutputSequence, AlignPtr, SeqData.Data.Header, OutputSequenceLength, 0.0f );
								pthread_mutex_unlock(PrintLock);
							}
						} ]]
					}
					
					/* Return the job memory slot */
					pthread_mutex_lock(&thpool->donequeue_p.rwmutex);
					jobqueue_push(&thpool->donequeue_p, (job_t*) task);
					pthread_mutex_unlock(&thpool->donequeue_p.rwmutex);
				}
				pthread_mutex_lock(&thpool->thcount_lock);
				thpool->num_threads_working--;
				pthread_mutex_unlock(&thpool->thcount_lock);
			}
    }
		
		/////////////////////////////////////////////////////////////////////////////////////////////////////////
		//SUMMARIZE;
		common->Counters[_Data->threadID] = AlignedSeqCounter;
     
    FIN:
    pthread_mutex_lock(&thpool->thcount_lock);
    thpool->num_threads_alive--;
    pthread_mutex_unlock(&thpool->thcount_lock);
		    
		if (WORK) _mm_free(WORK);
		if (matrix) _mm_free(matrix);
		$if WITH_REVERSE [[ if (rvmatrix) _mm_free(rvmatrix); ]]
		if (SequenceText) free(SequenceText);
		$if (WRAPPER_TEXT == 1) [[ ]] $else [[ free(HasAPath); ]]
		$if ((WRAPPER_TEXT == 0)|(WRAPPER_TEXT == 5)) [[ free(OutputSequence); ]]
		$if (WRAPPER_TEXT == 4) [[ free(BackupSequence); ]]
		
    if( res != SUCCESS) {
      fprintf(stderr, "Thread %u error code %i\n", _Data->threadID, res);
      if (task) {
				pthread_mutex_lock(&thpool->thcount_lock);
				thpool->num_threads_working--;
				pthread_mutex_unlock(&thpool->thcount_lock);
      }
      thpool->threads_keepalive = 0;
    }
    
    _Data->returnState = (void*) (uintptr_t) res;
		
    return 0;
}
$if (CYCLE_RANGE == 1) [[

#else
{
		fputs("Enable PRF_CORE_REPEAT for cycles!\n", stderr);
		return (void*) 1;
}
#endif

]]

]]
]] ]] ]] ]] ]]
]]

/****************************************************************************************************
 * MATRIX PROFILES: HISTOGRAM
 */
$for HISTO_CYCLE [[
$for CYCLE_RANGE [[ $for SCORE_RANGE [[ $for BORDER_CLIP [[ $for WITH_REVERSE [[
$if (SCORE_RANGE | (HISTO_CYCLE & CYCLE_RANGE)) [[

static
THREADPOOL_FUNCTION(tpfaph$HISTO_CYCLE$BORDER_CLIP$CYCLE_RANGE$SCORE_RANGE$WITH_REVERSE)
$if (CYCLE_RANGE == 1) [[

#ifdef PRF_CORE_REPEAT

]]
{
		int res = SUCCESS;
		$if WITH_REVERSE [[
			unsigned char RevComp_Index_Mapping[ALPHABET_SIZE+2] __attribute__((aligned(16)));
		]]
// 	  printf("Thread started fct THREAD_FCT_NAME\n");
		
		/*************************************************************************/
    /*                          GET COMMON DATA                              */
    /*************************************************************************/
		common_t * const common = _Data->common;
		
		/* For profile search we need to have */
		const struct Profile * const restrict prf = common->profile;
		const Compute_t * const restrict CoreCompute =common->Compute;
		
		/* For output we need */
		$if HISTO_CYCLE [[
			const unsigned short int range[2] = { (common->OutputType)->CycleRange[0], 
																						(common->OutputType)->CycleRange[1] }; 
			$if SCORE_RANGE [[
				const int ScoreRange[2] = { (common->OutputType)->ScoreRange[0],
																		(common->OutputType)->ScoreRange[1] };
			]]
		]] $else [[
			const int range[2] = { (common->OutputType)->ScoreRange[0],
														 (common->OutputType)->ScoreRange[1] };
			$if CYCLE_RANGE [[
					const unsigned int CycleRange[2] = { (common->OutputType)->CycleRange[0], 
																							 (common->OutputType)->CycleRange[1] };
			]]
		]]
		
		$if BORDER_CLIP [[
			unsigned short int  BorderClip[2] =  { (common->OutputType)->BorderClip[0],
																						 (common->OutputType)->BorderClip[1] };
		
		]]
		const size_t HistogramBins = range[1] - range[0] + 1;
		size_t * const restrict Histogram = common->Histograms + HistogramBins*(_Data->threadID);
		
		/*************************************************************************/
    /*                          ALLOCATE MEMORY                              */
    /*************************************************************************/
		const size_t prfLength = prf->Length;
		const size_t matrixLD  = prf->Length + 1;
		size_t LargestSequence = 2048;
		union lScores * restrict matrix = _mm_malloc(matrixLD*LargestSequence*sizeof(union lScores), 64);
		$if WITH_REVERSE [[
			union lScores * restrict rvmatrix = _mm_malloc(matrixLD*LargestSequence*sizeof(union lScores), 64);
		]]
		unsigned char * restrict SequenceText = malloc(LargestSequence*sizeof(unsigned char));
		int * restrict WORK = _mm_malloc(GetWorkArraySize(prf, CoreCompute),64);
		if ( $if WITH_REVERSE [[ rvmatrix == NULL || ]] matrix == NULL || WORK == NULL || SequenceText == NULL ) {
			res = -1; 
			goto FIN;
		}
		
		/*************************************************************************/
		/*                          CONFIGURE WORKER                             */
		/*************************************************************************/
		$if WITH_REVERSE [[
			for (unsigned char a=0;a<ALPHABET_SIZE+2; a++) RevComp_Index_Mapping[a] = a;
			{
				unsigned char c;
				c = RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'A' - (int) 'A' ] ];
				RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'A' - (int) 'A' ] ] = RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'T' - (int) 'A' ] ];
				RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'T' - (int) 'A' ] ] = c;
			}
			{
				unsigned char c;
				c = RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'C' - (int) 'A' ] ];
				RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'C' - (int) 'A' ] ] = RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'G' - (int) 'A' ] ];
				RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'G' - (int) 'A' ] ] = c;
			}
		]]
		
		/* Assure all threads have been created before starting serving */
		threadpool_t* const restrict  thpool = _Data->thpool;
   
//		/* Register signal handler */
//     struct sigaction act;
//     act.sa_handler = thread_hold;
//     if (sigaction(SIGUSR1, &act, NULL) == -1) {
// 	    fprintf(stderr, "thread_do(): cannot handle SIGUSR1");
//     }
    
		/* Mark thread as alive (initialized) */
		pthread_mutex_lock(&thpool->thcount_lock);
		thpool->num_threads_alive += 1;
		pthread_mutex_unlock(&thpool->thcount_lock);

		// Initialize some other data
		fasta_job_t * task = NULL;
		size_t Missed = 0UL;
		
		while(thpool->threads_keepalive) {
			bsem_wait(thpool->jobqueue_p.has_items);
			
			if (thpool->threads_keepalive){
				pthread_mutex_lock(&thpool->thcount_lock);
				thpool->num_threads_working++;
				pthread_mutex_unlock(&thpool->thcount_lock);
				
				/* Read job from queue and execute it */
				pthread_mutex_lock(&thpool->jobqueue_p.rwmutex);
				task = (fasta_job_t*) jobqueue_pull(&thpool->jobqueue_p);
				pthread_mutex_unlock(&thpool->jobqueue_p.rwmutex);
				
				/***************************************************************/
				/*                     START THE TASK                          */
				/***************************************************************/
				if (task) {
					/* Transform into real Fasta sequence and split header and data */
					Sequence_t SeqData = task->Fasta_Sequence;
					if (SeqData.ProfileData.Length > 0UL) {
						CleanSequence(&(SeqData.ProfileData));
						PFSequence * restrict PFSeq = &(SeqData.ProfileData);
												
						/* Check memory allocated size */
						if (PFSeq->Length >= LargestSequence) {
							LargestSequence = (PFSeq->Length + 1UL + 2047UL) & ~(2047UL);
							_mm_free(matrix);
							$if WITH_REVERSE [[ _mm_free(rvmatrix); ]]
							matrix = _mm_malloc(matrixLD*LargestSequence*sizeof(union lScores), 64);
							$if WITH_REVERSE [[
								rvmatrix = _mm_malloc(matrixLD*LargestSequence*sizeof(union lScores), 64);
							]]
							if ( $if WITH_REVERSE [[rvmatrix == NULL ||]] matrix == NULL ) {
								res = -1; 
								goto FIN;
							}
						}
												
						/* Translate first sequence */
						PFSeq = TranslateSequenceToIndex(PFSeq, prf->Alphabet_Mapping);
						CoreCompute->BuildMatrix(prf, PFSeq->ProfileIndex, matrix, WORK, NULL, 0, PFSeq->Length);
						
						$if WITH_REVERSE [[
							RevCompIndex(PFSeq, RevComp_Index_Mapping);
							CoreCompute->BuildMatrix(prf, PFSeq->ProfileIndex, rvmatrix, WORK, NULL, 0, PFSeq->Length);
						]]
						
						/////////////////////////////////////////////////////////////////////////////////////////////////////////
						// WORK_ON_MATRICES;
						/**************************************** Histogram **************************************************/
						$if CYCLE_RANGE [[ {
							ScoreCycle_t SC $if WITH_REVERSE [[ , rvSC ]] ;
							GetBestScoreAndCycles(matrix, PFSeq->Length, prfLength, &SC);

							$if WITH_REVERSE [[ GetBestScoreAndCycles(rvmatrix, PFSeq->Length, prfLength, &rvSC); ]]
							$if BORDER_CLIP [[
								if ((SC.Begin <= BorderClip[0]) || (SC.End+BorderClip[1] >= PFSeq->Length)) {
									$if SCORE_RANGE [[ SC.Score = NLOW; ]]
									$if CYCLE_RANGE [[ SC.Cycles = 0; ]]
								}
							]]
							$if (HISTO_CYCLE & SCORE_RANGE) [[
								if (SC.Score < ScoreRange[0] || SC.Score > ScoreRange[1]) {
									SC.Cycles = 0;
								}
								$if WITH_REVERSE [[
									if (rvSC.Score < ScoreRange[0] || rvSC.Score > ScoreRange[1]) {
										rvSC.Cycles = 0;
									}
								]]
							]]
							$if (CYCLE_RANGE & ~(HISTO_CYCLE)) [[
								if (SC.Cycles < CycleRange[0] || SC.Cycles > CycleRange[1]) {
									SC.Score = NLOW;
								}
								$if WITH_REVERSE [[
									if (rvSC.Cycles < CycleRange[0] || rvSC.Cycles > CycleRange[1]) {
										rvSC.Score = NLOW;
									}
								]]
							]]
							
							$if WITH_REVERSE [[
								$if BORDER_CLIP [[
									if ((rvSC.Begin <= BorderClip[0]) || (rvSC.End+BorderClip[1] >= PFSeq->Length)) {
										$if SCORE_RANGE [[ rvSC.Score = NLOW; ]]
										$if CYCLE_RANGE [[ rvSC.Cycles = 0; ]]
									}
								]]
								$if HISTO_CYCLE [[
									if (rvSC.Cycles > SC.Cycles) SC.Cycles = rvSC.Cycles;
								]] $else [[
									if (rvSC.Score > SC.Score) SC.Score = rvSC.Score;
								]]
							]]
							
							$if HISTO_CYCLE [[
								if (SC.Cycles >= range[0] && SC.Cycles <= range[1]) {
									Histogram[SC.Cycles-range[0] ]++;
								}
								else 
									Missed++;
							]]
							$else [[
								if (SC.Score >= range[0] && SC.Score <= range[1]) {
									Histogram[SC.Score-range[0] ]++;
								}
								else 
									Missed++;
							]]
						} ]]
						$else [[ {
							$if BORDER_CLIP [[
								Alignment_t Alignment;
								CoreCompute->GetBestAlignment(matrix, &Alignment, PFSeq->Length, prfLength);
								if ( (Alignment.Region.sequence.Begin <= BorderClip[0]) 
									|| (Alignment.Region.sequence.End+BorderClip[1] >= PFSeq->Length)) {
									Alignment.Score = NLOW;
								}
								$if WITH_REVERSE [[
									Alignment_t rvAlignment;
									CoreCompute->GetBestAlignment(rvmatrix, &rvAlignment, PFSeq->Length, prfLength);
									if ( (rvAlignment.Region.sequence.Begin <= BorderClip[0]) 
										|| (rvAlignment.Region.sequence.End+BorderClip[1] >= PFSeq->Length)) {
										rvAlignment.Score = NLOW;
									}
									else {
										if (rvAlignment.Score > Alignment.Score) Alignment.Score = rvAlignment.Score;
									}
								]]
								if (Alignment.Score >= range[0] && Alignment.Score <= range[1])
									Histogram[Alignment.Score-range[0] ]++;
								else
									Missed++;
							]]
							$else [[
								int Score = CoreCompute->GetBestScore(matrix, PFSeq->Length, prfLength);
								$if WITH_REVERSE [[
									const int rvScore = CoreCompute->GetBestScore(rvmatrix, PFSeq->Length, prfLength);
									if (rvScore > Score) Score = rvScore;
								]]
								if (Score >= range[0] && Score <= range[1]) {
									Histogram[Score-range[0] ]++;
								}
								else 
									Missed++;
								]]
						} ]]
					}
					
					/* Return the job memory slot */
					pthread_mutex_lock(&thpool->donequeue_p.rwmutex);
					jobqueue_push(&thpool->donequeue_p, (job_t*) task);
					pthread_mutex_unlock(&thpool->donequeue_p.rwmutex);
				}
				pthread_mutex_lock(&thpool->thcount_lock);
				thpool->num_threads_working--;
				pthread_mutex_unlock(&thpool->thcount_lock);
			}
    }
		
		/////////////////////////////////////////////////////////////////////////////////////////////////////////
		//SUMMARIZE;
		common->Counters[_Data->threadID] = Missed;
     
    FIN:
    pthread_mutex_lock(&thpool->thcount_lock);
    thpool->num_threads_alive--;
    pthread_mutex_unlock(&thpool->thcount_lock);
		    
		if (WORK) _mm_free(WORK);
		if (matrix) _mm_free(matrix);
		$if WITH_REVERSE [[ if (rvmatrix) _mm_free(rvmatrix); ]]
		if (SequenceText) free(SequenceText);
		
    if( res != SUCCESS) {
      fprintf(stderr, "Thread %u error code %i\n", _Data->threadID, res);
      if (task) {
				pthread_mutex_lock(&thpool->thcount_lock);
				thpool->num_threads_working--;
				pthread_mutex_unlock(&thpool->thcount_lock);
      }
      thpool->threads_keepalive = 0;
    }
    
    _Data->returnState = (void*) (uintptr_t) res;
		
    return 0;
}
$if (CYCLE_RANGE == 1) [[

#else
{
		fputs("Enable PRF_CORE_REPEAT for cycles!\n", stderr);
		return (void*) 1;
}
#endif

]]

]]
]] ]] ]] ]]
]]


/****************************************************************************************************
 * MATRIX PROFILES: DENSITY
 */
$for WITH_REVERSE [[

static
THREADPOOL_FUNCTION(tpfapd$WITH_REVERSE)
#ifdef PRF_CORE_REPEAT
{
		int res = SUCCESS;
		$if WITH_REVERSE [[
			unsigned char RevComp_Index_Mapping[ALPHABET_SIZE+2] __attribute__((aligned(16)));
		]]
// 	  printf("Thread started fct THREAD_FCT_NAME\n");
		
		/*************************************************************************/
    /*                          GET COMMON DATA                              */
    /*************************************************************************/
		common_t * const common = _Data->common;
		
		/* For profile search we need to have */
		const struct Profile * const restrict prf = common->profile;
		const Compute_t * const restrict CoreCompute =common->Compute;
		
		/* For output we need */
		const unsigned short int CycleRange[2] = { (common->OutputType)->CycleRange[0], 
		                                           (common->OutputType)->CycleRange[1] }; 
		const int ScoreRange[2] = { (common->OutputType)->ScoreRange[0],
		                            (common->OutputType)->ScoreRange[1] };
		const size_t HistogramBins = ScoreRange[1] - ScoreRange[0] + 1;
		const size_t Density_LD = CycleRange[1] - CycleRange[0] + 1;
		size_t * const restrict Histogram = common->Histograms + Density_LD*HistogramBins*_Data->threadID;
		
		/*************************************************************************/
    /*                          ALLOCATE MEMORY                              */
    /*************************************************************************/
		const size_t prfLength = prf->Length;
		const size_t matrixLD  = prf->Length + 1;
		size_t LargestSequence = 2048;
		union lScores * restrict matrix = _mm_malloc(matrixLD*LargestSequence*sizeof(union lScores), 64);
		$if WITH_REVERSE [[
			union lScores * restrict rvmatrix = _mm_malloc(matrixLD*LargestSequence*sizeof(union lScores), 64);
		]]
		unsigned char * restrict SequenceText = malloc(LargestSequence*sizeof(unsigned char));
		int * restrict WORK          = _mm_malloc(GetWorkArraySize(prf, CoreCompute),64);
		if ( $if WITH_REVERSE [[ rvmatrix == NULL || ]] matrix == NULL || WORK == NULL || SequenceText == NULL ) {
			res = -1; 
			goto FIN;
		}
		
		/*************************************************************************/
		/*                          CONFIGURE WORKER                             */
		/*************************************************************************/
		$if WITH_REVERSE [[
			for (unsigned char a=0;a<ALPHABET_SIZE+2; a++) RevComp_Index_Mapping[a] = a;
			{
				unsigned char c;
				c = RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'A' - (int) 'A' ] ];
				RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'A' - (int) 'A' ] ] = RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'T' - (int) 'A' ] ];
				RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'T' - (int) 'A' ] ] = c;
			}
			{
				unsigned char c;
				c = RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'C' - (int) 'A' ] ];
				RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'C' - (int) 'A' ] ] = RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'G' - (int) 'A' ] ];
				RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'G' - (int) 'A' ] ] = c;
			}
		]]
		
		/* Assure all threads have been created before starting serving */
		threadpool_t* const restrict  thpool = _Data->thpool;
   
//		/* Register signal handler */
//     struct sigaction act;
//     act.sa_handler = thread_hold;
//     if (sigaction(SIGUSR1, &act, NULL) == -1) {
// 	    fprintf(stderr, "thread_do(): cannot handle SIGUSR1");
//     }
    
		/* Mark thread as alive (initialized) */
		pthread_mutex_lock(&thpool->thcount_lock);
		thpool->num_threads_alive += 1;
		pthread_mutex_unlock(&thpool->thcount_lock);

		// Initialize some other data
		fasta_job_t * task = NULL;
		size_t Missed = 0UL;
		
		while(thpool->threads_keepalive) {
			bsem_wait(thpool->jobqueue_p.has_items);
			
			if (thpool->threads_keepalive){
				pthread_mutex_lock(&thpool->thcount_lock);
				thpool->num_threads_working++;
				pthread_mutex_unlock(&thpool->thcount_lock);
				
				/* Read job from queue and execute it */
				pthread_mutex_lock(&thpool->jobqueue_p.rwmutex);
				task = (fasta_job_t*) jobqueue_pull(&thpool->jobqueue_p);
				pthread_mutex_unlock(&thpool->jobqueue_p.rwmutex);
				
				/***************************************************************/
				/*                     START THE TASK                          */
				/***************************************************************/
				if (task) {
					/* Transform into real Fasta sequence and split header and data */
					Sequence_t SeqData = task->Fasta_Sequence;
					if (SeqData.ProfileData.Length > 0UL) {
						size_t SeqLength = 0UL;
						{
							unsigned char * restrict ptr = SeqData.ProfileData.ProfileIndex;
							const unsigned char * const limit = ptr + SeqData.ProfileData.Length; 
							while ( ptr < limit) {
								register unsigned char c = *ptr++;
								c = (c >= 'a') ? c - ('a' - 'A') : c;
								if (c >= 'A' && c <= 'Z') 
									SeqData.ProfileData.ProfileIndex[SeqLength++] = c;
							}
							SeqData.ProfileData.Length = SeqLength;
						}
						
						/* Check memory allocated size */
						if (SeqLength >= LargestSequence) {
							LargestSequence = (SeqLength + 1UL + 2047UL) & ~(2047UL);
							_mm_free(matrix);
							$if WITH_REVERSE [[ _mm_free(rvmatrix); ]]
							matrix = _mm_malloc(matrixLD*LargestSequence*sizeof(union lScores), 64);
							$if WITH_REVERSE [[
								rvmatrix = _mm_malloc(matrixLD*LargestSequence*sizeof(union lScores), 64);
							]]
							SequenceText = realloc(SequenceText, LargestSequence*sizeof(unsigned char));
							if ( $if WITH_REVERSE [[rvmatrix == NULL ||]] matrix == NULL || SequenceText == NULL) {
								res = -1; 
								goto FIN;
							}
						}
						memcpy(SequenceText, SeqData.ProfileData.ProfileIndex, SeqLength); SequenceText[SeqLength] = '\0';
												
						/* Translate first sequence */
						PFSequence * restrict PFSeq = TranslateSequenceToIndex(&(SeqData.ProfileData), prf->Alphabet_Mapping);
						CoreCompute->BuildMatrix(prf, PFSeq->ProfileIndex, matrix, WORK, NULL, 0, SeqLength);
						
						$if WITH_REVERSE [[
							RevCompIndex(PFSeq, RevComp_Index_Mapping);
							CoreCompute->BuildMatrix(prf, PFSeq->ProfileIndex, rvmatrix, WORK, NULL, 0, SeqLength);
						]]
						
						/////////////////////////////////////////////////////////////////////////////////////////////////////////
						// WORK_ON_MATRICES;
						ScoreCycle_t SC $if WITH_REVERSE [[, rvSC]];
						GetBestScoreAndCycles(matrix, SeqLength, prfLength, &SC);
						$if WITH_REVERSE [[
							GetBestScoreAndCycles(rvmatrix, SeqLength, prfLength, &rvSC);
							int Score = (rvSC.Score > SC.Score) ? rvSC.Score : SC.Score;
							unsigned int Cycles = (rvSC.Score > SC.Score) ? rvSC.Cycles : SC.Cycles;
							if (Score>=ScoreRange[0] && Score<ScoreRange[1] && Cycles>=CycleRange[0] && Cycles<CycleRange[1]) {
								const size_t index = Score - ScoreRange[0];
								Histogram[index*Density_LD+Cycles-CycleRange[0] ]++;
							}
							else {
								Missed++;
							}
						]] $else [[
							if (SC.Score>=ScoreRange[0] && SC.Score<ScoreRange[1] && SC.Cycles>=CycleRange[0] && SC.Cycles<CycleRange[1]) {
								const size_t index = SC.Score - ScoreRange[0];
								Histogram[index*Density_LD+SC.Cycles-CycleRange[0] ]++;
							}
							else {
								Missed++;
							}
						]]
					}
					
					/* Return the job memory slot */
					pthread_mutex_lock(&thpool->donequeue_p.rwmutex);
					jobqueue_push(&thpool->donequeue_p, (job_t*) task);
					pthread_mutex_unlock(&thpool->donequeue_p.rwmutex);
				}
				pthread_mutex_lock(&thpool->thcount_lock);
				thpool->num_threads_working--;
				pthread_mutex_unlock(&thpool->thcount_lock);
			}
    }
		
		/////////////////////////////////////////////////////////////////////////////////////////////////////////
		//SUMMARIZE;
		common->Counters[_Data->threadID] = Missed;
     
    FIN:
    pthread_mutex_lock(&thpool->thcount_lock);
    thpool->num_threads_alive--;
    pthread_mutex_unlock(&thpool->thcount_lock);
		    
		if (WORK) _mm_free(WORK);
		if (matrix) _mm_free(matrix);
		$if WITH_REVERSE [[ if (rvmatrix) _mm_free(rvmatrix); ]]
		if (SequenceText) free(SequenceText);
		
    if( res != SUCCESS) {
      fprintf(stderr, "Thread %u error code %i\n", _Data->threadID, res);
      if (task) {
				pthread_mutex_lock(&thpool->thcount_lock);
				thpool->num_threads_working--;
				pthread_mutex_unlock(&thpool->thcount_lock);
      }
      thpool->threads_keepalive = 0;
    }
    
    _Data->returnState = (void*) (uintptr_t) res;
		
    return 0;
}
#else
{
		fputs("Enable PRF_CORE_REPEAT for cycles!\n", stderr);
		return (void*) 1;
}
#endif

]]


/****************************************************************************************************
 * MATRIX PROFILES: OTHER
 */
$for WITH_REVERSE [[

static
THREADPOOL_FUNCTION(tpfapo$WITH_REVERSE)
{
		int res = SUCCESS;
		$if WITH_REVERSE [[
			unsigned char RevComp_Index_Mapping[ALPHABET_SIZE+2] __attribute__((aligned(16)));
		]]
// 	  printf("Thread started fct THREAD_FCT_NAME\n");
		
		/*************************************************************************/
		/*                          GET COMMON DATA                              */
		/*************************************************************************/
		common_t * const common = _Data->common;
		
		/* For profile search we need to have */
		const struct Profile * const restrict prf = common->profile;
		const Compute_t * const restrict CoreCompute = common->Compute;
		
		/* For output we need */
		OutputMethod Output = (common->OutputType)->OutputFct;
		pthread_mutex_t * const restrict PrintLock = &(common->PrintLock);
		const void * const OutputMethodOptions = &((common->OutputType)->Specific);
		
		/*************************************************************************/
    /*                          ALLOCATE MEMORY                              */
    /*************************************************************************/
		const size_t prfLength = prf->Length;
		const size_t matrixLD  = prf->Length + 1;
		size_t LargestSequence = 2048;
		union lScores * restrict matrix = _mm_malloc(matrixLD*LargestSequence*sizeof(union lScores), 64);
		$if WITH_REVERSE [[
			union lScores * restrict rvmatrix = _mm_malloc(matrixLD*LargestSequence*sizeof(union lScores), 64);
		]]
		unsigned char * restrict SequenceText = malloc(LargestSequence*sizeof(unsigned char));
		int * restrict WORK          = _mm_malloc(GetWorkArraySize(prf, CoreCompute),64);
		if ( $if WITH_REVERSE [[ rvmatrix == NULL || ]] matrix == NULL || WORK == NULL || SequenceText == NULL ) {
			res = -1; 
			goto FIN;
		}
		
		/*************************************************************************/
		/*                          CONFIGURE WORKER                             */
		/*************************************************************************/
		$if WITH_REVERSE [[
			for (unsigned char a=0;a<ALPHABET_SIZE+2; a++) RevComp_Index_Mapping[a] = a;
			{
				unsigned char c;
				c = RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'A' - (int) 'A' ] ];
				RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'A' - (int) 'A' ] ] = RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'T' - (int) 'A' ] ];
				RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'T' - (int) 'A' ] ] = c;
			}
			{
				unsigned char c;
				c = RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'C' - (int) 'A' ] ];
				RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'C' - (int) 'A' ] ] = RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'G' - (int) 'A' ] ];
				RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'G' - (int) 'A' ] ] = c;
			}
		]]
		
		/* Assure all threads have been created before starting serving */
		threadpool_t* const restrict  thpool = _Data->thpool;
   
//		/* Register signal handler */
//     struct sigaction act;
//     act.sa_handler = thread_hold;
//     if (sigaction(SIGUSR1, &act, NULL) == -1) {
// 	    fprintf(stderr, "thread_do(): cannot handle SIGUSR1");
//     }
    
		/* Mark thread as alive (initialized) */
		pthread_mutex_lock(&thpool->thcount_lock);
		thpool->num_threads_alive += 1;
		pthread_mutex_unlock(&thpool->thcount_lock);

		// Initialize some other data
		fasta_job_t * task = NULL;

		const int CutOff = prf->CutOff;

		while(thpool->threads_keepalive) {
			bsem_wait(thpool->jobqueue_p.has_items);
			
			if (thpool->threads_keepalive){
				pthread_mutex_lock(&thpool->thcount_lock);
				thpool->num_threads_working++;
				pthread_mutex_unlock(&thpool->thcount_lock);
				
				/* Read job from queue and execute it */
				pthread_mutex_lock(&thpool->jobqueue_p.rwmutex);
				task = (fasta_job_t*) jobqueue_pull(&thpool->jobqueue_p);
				pthread_mutex_unlock(&thpool->jobqueue_p.rwmutex);
				
				/***************************************************************/
				/*                     START THE TASK                          */
				/***************************************************************/
				if (task) {
					/* Transform into real Fasta sequence and split header and data */
					Sequence_t SeqData = task->Fasta_Sequence;
					if (SeqData.ProfileData.Length > 0UL) {
						size_t SeqLength = 0UL;
						{
							unsigned char * restrict ptr = SeqData.ProfileData.ProfileIndex;
							const unsigned char * const limit = ptr + SeqData.ProfileData.Length; 
							while ( ptr < limit) {
								register unsigned char c = *ptr++;
								c = (c >= 'a') ? c - ('a' - 'A') : c;
								if (c >= 'A' && c <= 'Z') 
									SeqData.ProfileData.ProfileIndex[SeqLength++] = c;
							}
							SeqData.ProfileData.Length = SeqLength;
						}
						
						/* Check memory allocated size */
						if (SeqLength >= LargestSequence) {
							LargestSequence = (SeqLength + 1UL + 2047UL) & ~(2047UL);
							_mm_free(matrix);
							$if WITH_REVERSE [[ _mm_free(rvmatrix); ]]
							matrix = _mm_malloc(matrixLD*LargestSequence*sizeof(union lScores), 64);
							$if WITH_REVERSE [[
								rvmatrix = _mm_malloc(matrixLD*LargestSequence*sizeof(union lScores), 64);
							]]
							SequenceText = realloc(SequenceText, LargestSequence*sizeof(unsigned char));
							if ( $if WITH_REVERSE [[rvmatrix == NULL ||]] matrix == NULL || SequenceText == NULL) {
								res = -1; 
								goto FIN;
							}
						}
						memcpy(SequenceText, SeqData.ProfileData.ProfileIndex, SeqLength); SequenceText[SeqLength] = '\0';
												
						/* Translate first sequence */
						PFSequence * restrict PFSeq = TranslateSequenceToIndex(&(SeqData.ProfileData), prf->Alphabet_Mapping);
						CoreCompute->BuildMatrix(prf, PFSeq->ProfileIndex, matrix, WORK, NULL, 0, SeqLength);
						
						$if WITH_REVERSE [[
							RevCompIndex(PFSeq, RevComp_Index_Mapping);
							CoreCompute->BuildMatrix(prf, PFSeq->ProfileIndex, rvmatrix, WORK, NULL, 0, SeqLength);
						]]
						
						/////////////////////////////////////////////////////////////////////////////////////////////////////////
						// WORK_ON_MATRICES;
						Output(matrix, $if WITH_REVERSE [[ rvmatrix ]] $else [[ NULL ]], SequenceText, SeqData.Data.Header,
						       prf, CoreCompute, SeqLength, OutputMethodOptions, PrintLock);
					}
					
					/* Return the job memory slot */
					pthread_mutex_lock(&thpool->donequeue_p.rwmutex);
					jobqueue_push(&thpool->donequeue_p, (job_t*) task);
					pthread_mutex_unlock(&thpool->donequeue_p.rwmutex);
				}
				pthread_mutex_lock(&thpool->thcount_lock);
				thpool->num_threads_working--;
				pthread_mutex_unlock(&thpool->thcount_lock);
			}
    }
     
    FIN:
    pthread_mutex_lock(&thpool->thcount_lock);
    thpool->num_threads_alive--;
    pthread_mutex_unlock(&thpool->thcount_lock);
		    
		if (WORK) _mm_free(WORK);
		if (matrix) _mm_free(matrix);
		$if WITH_REVERSE [[ if (rvmatrix) _mm_free(rvmatrix); ]]
		if (SequenceText) free(SequenceText);
		
    if( res != SUCCESS) {
      fprintf(stderr, "Thread %u error code %i\n", _Data->threadID, res);
      if (task) {
				pthread_mutex_lock(&thpool->thcount_lock);
				thpool->num_threads_working--;
				pthread_mutex_unlock(&thpool->thcount_lock);
      }
      thpool->threads_keepalive = 0;
    }
    
    _Data->returnState = (void*) (uintptr_t) res;
		
    return 0;
}

]]



static THREADPOOL_FUNCTION((*ltp_fap[])) = {
$for WRAPPER_TEXT [[
$for BORDER_CLIP [[ $for INVERSE_SELECTION [[ $for CYCLE_RANGE [[ $for SCORE_RANGE [[ $for WITH_REVERSE [[
$if ((WRAPPER_TEXT < 5) | WITH_REVERSE) [[
	tpfaps$WRAPPER_TEXT$BORDER_CLIP$INVERSE_SELECTION$CYCLE_RANGE$SCORE_RANGE$WITH_REVERSE,
]]
]] ]] ]] ]] ]]
]]

$for HISTO_CYCLE [[
$for CYCLE_RANGE [[ $for SCORE_RANGE [[ $for BORDER_CLIP [[ $for WITH_REVERSE [[
$if ((SCORE_RANGE & ~(HISTO_CYCLE)) | (HISTO_CYCLE & CYCLE_RANGE)) [[
	tpfaph$HISTO_CYCLE$BORDER_CLIP$CYCLE_RANGE$SCORE_RANGE$WITH_REVERSE,

]]
]] ]] ]] ]]
]]

$for WITH_REVERSE [[
	tpfapd$WITH_REVERSE,
]]


$for WITH_REVERSE [[
	tpfapo$WITH_REVERSE,
]]


	0
};

THREADPOOL_FUNCTION((* * tp_fap)) = ltp_fap;

