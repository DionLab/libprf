#include "prf_config.h"
#include <stdlib.h>
#include <stdio.h>
#include <pthread.h>
#include <assert.h>
#define __USE_INLINE_FUNCTIONS__
#include "pfProfile.h"
#include "pfSequence.h"
#include "pfOutput.h"
#include "FASTA_threads.h"
#ifndef PRF_CORE_REPEAT
static inline int __ALWAYS_INLINE
GetBestScoreAndCycles(const union lScores * const matrix,
 										  const size_t SeqLength, const size_t prfLength,
                      void * const restrict SC)
{
	return 0;
}
#endif
#define HEADER_STACK_SIZE 256

/****************************************************************************************************
 * From the following enums, we define the ordering as follow
 * 
enum SearchType { PRF=1, REGEX=2 };
enum OutputType { TEXT, HISTOGRAM, DENSITY, PNG, DATA, PDF };
enum Constrain { WITH_REVERSE=1, SCORE_RANGE=2, CYCLE_RANGE=4, INVERSE_SELECTION=8, BORDER_CLIP=16};
enum WrapperRange { Wrapper_Alignement = 0, Wrapper_Source = 1, Wrapper_Before = 2, Wrapper_After = 3,
	                  Wrapper_Outer = 4};

	MATRIX PRF:
		TEXT:																								: 160 cases
			- WITH_REVERSE
			- SCORE_RANGE
			- CYCLE_RANGE if circular profile only
			- INVERSE_SELECTION
			- BORDER_CLIP
			- WRAPPER (5 cases)
			
		HISTOGRAM:																					:  4 cases
			- WITH_REVERSE
			- SCORE_RANGE 
			- CYCLE_RANGE if circular profile only
			
		DENSITY: if circular profile												:  2 cases
			- WITH_REVERSE
			- SCORE_RANGE required anyway
			- CYCLE_RANGE required anyway
	
		PDF, PNG, DATA:																			: 2 cases
			- WITH_REVERSE
	
	
	REGEX or PATTERN PRF:
		TEXT:																								: 32 cases
			- WITH_REVERSE
			- SCORE_RANGE
			- CYCLE_RANGE
			- INVERSE_SELECTION
			- BORDER_CLIP
		
		HISTOGRAM:																					:  6 cases
			- WITH_REVERSE
			- SCORE_RANGE 
			- CYCLE_RANGE if circular profile only
			
		DENSITY:																						:  2 cases
			- WITH_REVERSE
			- SCORE_RANGE required anyway
			- CYCLE_RANGE required anyway
*****************************************************************************************************/

$range WITH_REVERSE 0..1
$range SCORE_RANGE 0..1
$range CYCLE_RANGE 0..1
$range HISTO_CYCLE 0..1
$range INVERSE_SELECTION 0..1
$range BORDER_CLIP 0..1
$range WRAPPER_TEXT 0..5

/****************************************************************************************************
 * External dependencies
 */
extern int compareAlignments(const void *a, const void *b);

/****************************************************************************************************
 * MATRIX PROFILES: TEXT
 */
$for WRAPPER_TEXT [[
$for BORDER_CLIP [[ $for INVERSE_SELECTION [[ $for CYCLE_RANGE [[ $for SCORE_RANGE [[ $for WITH_REVERSE [[
$if ((WRAPPER_TEXT < 5) | WITH_REVERSE) [[ 

static
THREAD_FUNCTION(tfaps$WRAPPER_TEXT$BORDER_CLIP$INVERSE_SELECTION$CYCLE_RANGE$SCORE_RANGE$WITH_REVERSE)
{
	$if (WRAPPER_TEXT == 1) [[ ]]
	$elif (WRAPPER_TEXT == 4) [[
		char NewHeader[1024]; 
	]]
	$else [[
		char NewHeader[HEADER_STACK_SIZE];
	]]
	$if WITH_REVERSE [[
		unsigned char RevComp_Index_Mapping[ALPHABET_SIZE+2] __attribute__((aligned(16)));
	]]
	
	Sequence_t SeqData;
	
	/*************************************************************************/
	/*                          GET COMMON DATA                              */
	/*************************************************************************/
	const FASTAStructure * const restrict FASTA = ((struct ThreadData*) _Data)->FASTA;
	const unsigned int * const restrict SeqID = ((struct ThreadData*) _Data)->SequenceID;
	
	/* For profile search we need to have */
	const struct Profile * const restrict prf = ((struct ThreadData*) _Data)->prf;
	const Compute_t * const restrict CoreCompute = ((struct ThreadData*) _Data)->Compute;
	
	/* For output we need */
	const OutputType_t * const restrict OutputType = ((struct ThreadData*) _Data)->OutputType;
	pthread_mutex_t * const restrict PrintLock = ((struct ThreadData*) _Data)->PrintLock;
	
	/*************************************************************************/
	/*                          GET COMMON DATA                              */
	/*************************************************************************/
	
	/* Allocate memory to hold sequence */
	unsigned char * restrict SequenceText = malloc(FASTA->MaxSequenceSize*sizeof(unsigned char));
	$if (WRAPPER_TEXT == 4) [[ unsigned char * restrict BackupSequence = malloc(FASTA->MaxSequenceSize*sizeof(unsigned char)); ]]
	SeqData.Data.Memory = malloc(FASTA->MaxSequenceSize*sizeof(unsigned char));
	if (SeqData.Data.Memory == NULL || SequenceText == NULL $if (WRAPPER_TEXT == 4) [[ | SequenceText == NULL ]] ) {
		fputs("Thread cannot allocate memory for sequence.\n", stderr);
		pthread_exit((void*)1);
	}

	/*************************************************************************/
	/*                          ALLOCATE MEMORY                              */
	/*************************************************************************/
	/* Allocate work aligned memory for xali1 */
	size_t matrixLD = prf->Length+1;
	union lScores * const restrict matrix = _mm_malloc(matrixLD*FASTA->MaxSequenceSize*sizeof(union lScores), 64);
	$if WITH_REVERSE [[
		union lScores * const restrict rvmatrix = _mm_malloc(matrixLD*FASTA->MaxSequenceSize*sizeof(union lScores), 64);
	]]
	int * const restrict WORK = _mm_malloc(GetWorkArraySize(prf, CoreCompute), 64);
	if ( $if WITH_REVERSE [[ rvmatrix == NULL || ]] matrix == NULL || WORK == NULL ) {
		if (WORK) _mm_free(WORK);
		if (matrix) _mm_free(matrix);
		$if WITH_REVERSE  [[ if (rvmatrix) _mm_free(rvmatrix); ]]
		free(SeqData.Data.Memory);
		free(SequenceText);
		pthread_exit((void*)1);
	}
	
	$if (WRAPPER_TEXT == 1) [[ ]] $else [[
		_Bool * restrict HasAPath;
		/*if (!(OutputType->Specific.Text.OptimalOnly))*/ {
			HasAPath = (_Bool*) malloc((1+FASTA->MaxSequenceSize)*sizeof(_Bool));
			if (HasAPath == NULL) {
				fprintf(stderr, "WrapperOutput unable to allocate HasAPath array of length %lu\n",
				        1+FASTA->MaxSequenceSize);
				pthread_exit((void*)1);
			}
		}
	]]
	$if ( (WRAPPER_TEXT == 0) | (WRAPPER_TEXT == 2) | (WRAPPER_TEXT == 3) | (WRAPPER_TEXT == 5)) [[
		size_t OutputSequenceMemorySize = 0UL;
		unsigned char * restrict OutputSequence = NULL;
	]] $elif (WRAPPER_TEXT == 4) [[
		size_t AlignmentsMemorySize = 10;
		Alignment_t * Alignments = (Alignment_t*) malloc(AlignmentsMemorySize*sizeof(Alignment_t));
		if (Alignments == NULL) {
			fprintf(stderr, "Unable to increase alignments'size to %lu\n", AlignmentsMemorySize);
			pthread_exit((void*) 1);
		}
	]]
	
	/*************************************************************************/
	/*                          CONFIGURE WORKER                             */
	/*************************************************************************/
	$if WITH_REVERSE  [[ 
		for (unsigned char a=0;a<ALPHABET_SIZE+2; a++) RevComp_Index_Mapping[a] = a;
		{
			unsigned char c;
			c = RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'A' - (int) 'A' ] ];
			RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'A' - (int) 'A' ] ] = RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'T' - (int) 'A' ] ];
			RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'T' - (int) 'A' ] ] = c;
		}
		{
			unsigned char c;
			c = RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'C' - (int) 'A' ] ];
			RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'C' - (int) 'A' ] ] = RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'G' - (int) 'A' ] ];
			RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'G' - (int) 'A' ] ] = c;
		}
	]]
	
	
	/* Open sequence file */
	SETUP_DATABASE_ACCESS(FASTA->SequenceFile);

	const size_t Start = ((struct ThreadData*) _Data)->start;
	const size_t Stop  = ((struct ThreadData*) _Data)->stop;
	const size_t prfLength = prf->Length;
	
	/////////////////////////////////////////////////////////////////////////////////////////////////////////
	//DECLARED_VARIABLES
	unsigned int AlignedSeqCounter=0U;

	/*****************************************************************/
	/*                    LOOPS ON SEQUENCES                         */
	/*****************************************************************/
	for (size_t i=Start; i<Stop; ++i) {
		PFSequence * PFSeq = GET_DATABASE_SEQUENCE(&SeqData, FASTA->DataPtr, i);

		/* Copy sequence to SequenceText */
		const size_t SeqLength = CleanSequenceTo(SequenceText, PFSeq->ProfileIndex, PFSeq->Length);
		
		/* Translate first sequence */
		PFSeq = TranslateSequenceToIndex(PFSeq, prf->Alphabet_Mapping);
		CoreCompute->BuildMatrix(prf, PFSeq->ProfileIndex, matrix, WORK, NULL, 0, SeqLength);
		
		$if WITH_REVERSE  [[ 
			RevCompIndex(PFSeq, RevComp_Index_Mapping);
			CoreCompute->BuildMatrix(prf, PFSeq->ProfileIndex, rvmatrix, WORK, NULL, 0, SeqLength);
		]]
		
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		// ALIGNMENT, SOURCE BEFORE AND AFTER OUTPUT
		$if ( (WRAPPER_TEXT == 0) | (WRAPPER_TEXT == 2) | (WRAPPER_TEXT == 3)) [[ {
			Alignment_t Alignment;
			Alignment.Orientation = 1;
			unsigned int count = 1U;
			memset(HasAPath, 0, (1+SeqLength)*sizeof(_Bool));
			do {
				/* Get Best Alignment */
				size_t OutputSequenceLength = CoreCompute->GetNextBestAlignment(matrix, HasAPath, &Alignment, SeqLength, prfLength);
				if (OutputSequenceLength == 0) {
					if (Alignment.Score >= prf->CutOff) {
						fprintf(stderr, "Issue as alignment does not start with an ENTRY point! (score=%i, seqlength=%lu)\n%s\n",
									Alignment.Score, SeqLength, SequenceText);
					}
					break;
				}
				
				/* Prevent further alignment to use this region */
				_Bool AlreadyUsed = false;
				assert(Alignment.Matrix.row.End <= SeqLength);
				assert(Alignment.Matrix.row.Begin >=0);
				for(int k=Alignment.Matrix.row.Begin; k<=Alignment.Matrix.row.End; ++k) {
					AlreadyUsed |= HasAPath[k]; 
					HasAPath[k] = true;
				}
					
				if (!AlreadyUsed) {
					_Bool KeepIt = true;
					$if SCORE_RANGE [[
						KeepIt &= (Alignment.Score >= OutputType->ScoreRange[0] && Alignment.Score <= OutputType->ScoreRange[1]);
					]]
					$if CYCLE_RANGE [[ 
						KeepIt &= (Alignment.Cycles >= OutputType->CycleRange[0] && Alignment.Cycles <= OutputType->CycleRange[1]);
					]]
					$if BORDER_CLIP [[
						KeepIt &= Alignment.Region.sequence.Begin >= OutputType->BorderClip[0]
									 && ((Alignment.Region.sequence.End + OutputType->BorderClip[1]) <= SeqLength);
					]]
					
					$if INVERSE_SELECTION [[
						KeepIt = !KeepIt;
					]]
					$if (BORDER_CLIP | SCORE_RANGE | CYCLE_RANGE | INVERSE_SELECTION) [[
						if (KeepIt)
					]] $else [[
						if ((Alignment.Score >= prf->CutOff || OutputType->Specific.Text.OptimalOnly) )
					]]
					{
						$if (WRAPPER_TEXT == 0) [[
							/* Get Aligned Sequence */
							if (OutputSequenceLength > OutputSequenceMemorySize) {
								OutputSequenceMemorySize = OutputSequenceLength; 
								OutputSequence = (unsigned char*) realloc(OutputSequence, OutputSequenceMemorySize*sizeof(unsigned char));
								if (OutputSequence == NULL) {
									fputs("Unable to allocate memory\n", stderr);
									exit(1);
								}
							}
					
							CoreCompute->GetAlignmentSequence(matrix, SequenceText, OutputSequence, &Alignment, SeqLength, prfLength);
						]]
						$elif (WRAPPER_TEXT == 2) [[
							OutputSequence = SequenceText;
							OutputSequenceLength = Alignment.Region.sequence.Begin - 1;
						]]
						$elif (WRAPPER_TEXT == 3) [[
							OutputSequence = SequenceText + Alignment.Region.sequence.End + 1;
							OutputSequenceLength = SeqLength - Alignment.Region.sequence.End;
						]]
						
						snprintf(NewHeader, HEADER_STACK_SIZE, "%s/%u", SeqData.Data.Header, count++);
						pthread_mutex_lock(PrintLock);
						OutputType->Specific.Text.Print(prf,
																						OutputSequence,
																						&Alignment, NewHeader, OutputSequenceLength, 0.0f);
						pthread_mutex_unlock(PrintLock);
						$if (BORDER_CLIP | SCORE_RANGE | CYCLE_RANGE | INVERSE_SELECTION) [[
							if (OutputType->Specific.Text.OptimalOnly) break;
						]]
					}
				}
				$if (BORDER_CLIP | SCORE_RANGE | CYCLE_RANGE) [[ ]] $else [[
					if (OutputType->Specific.Text.OptimalOnly) break;
				]]
			} while ($if SCORE_RANGE [[ Alignment.Score >= OutputType->ScoreRange[0] ]] $else [[ Alignment.Score >= prf->CutOff ]] );
			
			$if WITH_REVERSE [[
				memset(HasAPath, 0, (1+SeqLength)*sizeof(_Bool));
				PerformRevComp(SequenceText, SeqLength);
				Alignment.Orientation = -1;
				do {
					/* Get Best Alignment */
					size_t OutputSequenceLength = CoreCompute->GetNextBestAlignment(rvmatrix, HasAPath, &Alignment, SeqLength, prfLength);
					if (OutputSequenceLength == 0 ) {
						if (Alignment.Score >= prf->CutOff) {
							fprintf(stderr, "Issue as alignment does not start with an ENTRY point! (score=%i, seqlength=%lu)\n%s\n",
										Alignment.Score, SeqLength, SequenceText);
						}
						break;
					}
					
					/* Prevent further alignment to use this region */
					_Bool AlreadyUsed = false;
					assert(Alignment.Matrix.row.End <= SeqLength);
					assert(Alignment.Matrix.row.Begin >=0);
					for(int k=Alignment.Matrix.row.Begin; k<=Alignment.Matrix.row.End; ++k) {
						AlreadyUsed |= HasAPath[k]; 
						HasAPath[k] = true;
					}
						
					if (!AlreadyUsed) {
						_Bool KeepIt = true;
						$if SCORE_RANGE [[
							KeepIt &= (Alignment.Score >= OutputType->ScoreRange[0] && Alignment.Score <= OutputType->ScoreRange[1]);
						]]
						$if CYCLE_RANGE [[ 
							KeepIt &= (Alignment.Cycles >= OutputType->CycleRange[0] && Alignment.Cycles <= OutputType->CycleRange[1]);
						]]
						$if BORDER_CLIP [[
							KeepIt &= Alignment.Region.sequence.Begin >= OutputType->BorderClip[0]
										&& ((Alignment.Region.sequence.End + OutputType->BorderClip[1]) <= SeqLength);
						]]
						
						$if INVERSE_SELECTION [[
							KeepIt = !KeepIt;
						]]
						$if (BORDER_CLIP | SCORE_RANGE | CYCLE_RANGE | INVERSE_SELECTION) [[
							if (KeepIt)
						]] $else [[
							if ((Alignment.Score >= prf->CutOff || OutputType->Specific.Text.OptimalOnly) )
						]]
						{
							$if (WRAPPER_TEXT == 0) [[
								/* Get Aligned Sequence */
								if (OutputSequenceLength > OutputSequenceMemorySize) {
									OutputSequenceMemorySize = OutputSequenceLength; 
									OutputSequence = (unsigned char*) realloc(OutputSequence, OutputSequenceMemorySize*sizeof(unsigned char));
									if (OutputSequence == NULL) {
										fputs("Unable to allocate memory\n", stderr);
										exit(1);
									}
								}
						
								CoreCompute->GetAlignmentSequence(rvmatrix, SequenceText, OutputSequence, &Alignment, SeqLength, prfLength);
							]]
							$elif (WRAPPER_TEXT == 2) [[
								OutputSequence = SequenceText;
								OutputSequenceLength = Alignment.Region.sequence.Begin - 1;
							]]
							$elif (WRAPPER_TEXT == 3) [[
								OutputSequence = SequenceText + Alignment.Region.sequence.End + 1;
								OutputSequenceLength = SeqLength - Alignment.Region.sequence.End;
							]]
							
							snprintf(NewHeader, HEADER_STACK_SIZE, "%s/%u", SeqData.Data.Header, count++);
							pthread_mutex_lock(PrintLock);
							OutputType->Specific.Text.Print(prf,
																							OutputSequence,
																							&Alignment, NewHeader, OutputSequenceLength, 0.0f);
							pthread_mutex_unlock(PrintLock);
							$if (BORDER_CLIP | SCORE_RANGE | CYCLE_RANGE | INVERSE_SELECTION) [[
								if (OutputType->Specific.Text.OptimalOnly) break;
							]]
						}
					}
					$if (BORDER_CLIP | SCORE_RANGE | CYCLE_RANGE) [[ ]] $else [[
						if (OutputType->Specific.Text.OptimalOnly) break;
					]]
				}  while ($if SCORE_RANGE [[ Alignment.Score >= OutputType->ScoreRange[0] ]] $else [[ Alignment.Score >= prf->CutOff ]] );
			]]
		} ]]
		$elif (WRAPPER_TEXT == 4) [[ {
			///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			// IN_BETWEEN OUTPUT
			unsigned int count = 0U;
			memset(HasAPath, 0, (1+SeqLength)*sizeof(_Bool));
			Alignment_t * restrict Alignment;
			do {
				Alignment = &Alignments[count];
				Alignment->Orientation = 0;
				/* Get Best Alignment */
				size_t OutputSequenceLength = CoreCompute->GetNextBestAlignment(matrix, HasAPath, Alignment, SeqLength, prfLength);
				if (OutputSequenceLength == 0) {
					if (Alignment->Score >= prf->CutOff) {
						fprintf(stderr, "Issue as alignment does not start with an ENTRY point! (score=%i, seqlength=%lu)\n%s\n",
									Alignment->Score, SeqLength, SequenceText);
					}
					break;
				}
				
				/* Prevent further alignment to use this region */
				_Bool AlreadyUsed = false;
				assert(Alignment->Matrix.row.End <= SeqLength);
				assert(Alignment->Matrix.row.Begin >=0);
				for(int k=Alignment->Matrix.row.Begin; k<=Alignment->Matrix.row.End; ++k) {
					AlreadyUsed |= HasAPath[k]; 
					HasAPath[k] = true;
				}
					
				if (!AlreadyUsed) {
					_Bool KeepIt = true;
					$if SCORE_RANGE [[
						KeepIt &= (Alignment->Score >= OutputType->ScoreRange[0] && Alignment->Score <= OutputType->ScoreRange[1]);
					]]
					$if CYCLE_RANGE [[ 
						KeepIt &= (Alignment->Cycles >= OutputType->CycleRange[0] && Alignment->Cycles <= OutputType->CycleRange[1]);
					]]
					$if BORDER_CLIP [[
						KeepIt &= Alignment->Region.sequence.Begin >= OutputType->BorderClip[0]
									 && ((Alignment->Region.sequence.End + OutputType->BorderClip[1]) <= SeqLength);
					]]
					
					$if INVERSE_SELECTION [[
						KeepIt = !KeepIt;
					]]
					$if (BORDER_CLIP | SCORE_RANGE | CYCLE_RANGE | INVERSE_SELECTION) [[
						if (KeepIt)
					]] $else [[
						if ((Alignment->Score >= prf->CutOff || OutputType->Specific.Text.OptimalOnly) )
					]]
					{
						if (++count >= AlignmentsMemorySize) {
							AlignmentsMemorySize += 10;
							Alignments = (Alignment_t*) realloc(Alignments, AlignmentsMemorySize*sizeof(Alignment_t));
							if (Alignments == NULL) {
								fprintf(stderr, "Unable to increase alignments'size to %lu\n", AlignmentsMemorySize);
								pthread_exit((void*) 1);
							}
							Alignment = &Alignments[count-1];
						}
					}
				}
			}  while ($if SCORE_RANGE [[ OutputType->ScoreRange[0] ]] $else [[ Alignment->Score >= prf->CutOff ]] );
			
			$if WITH_REVERSE [[
				memset(HasAPath, 0, (1+SeqLength)*sizeof(_Bool));
				memcpy(BackupSequence, SequenceText, SeqLength);
				PerformRevComp(BackupSequence, SeqLength);
				do {
					Alignment = &Alignments[count];
					Alignment->Orientation = 0;
					/* Get Best Alignment */
					size_t OutputSequenceLength = CoreCompute->GetNextBestAlignment(rvmatrix, HasAPath, Alignment, SeqLength, prfLength);
					if (OutputSequenceLength == 0) {
						if (Alignment->Score >= prf->CutOff) {
							fprintf(stderr, "Issue as alignment does not start with an ENTRY point! (score=%i, seqlength=%lu)\n%s\n",
										Alignment->Score, SeqLength, SequenceText);
						}
						break;
					}
					
					/* Prevent further alignment to use this region */
					_Bool AlreadyUsed = false;
					assert(Alignment->Matrix.row.End <= SeqLength);
					assert(Alignment->Matrix.row.Begin >=0);
					for(int k=Alignment->Matrix.row.Begin; k<=Alignment->Matrix.row.End; ++k) {
						AlreadyUsed |= HasAPath[k]; 
						HasAPath[k] = true;
					}
						
					if (!AlreadyUsed) {
						_Bool KeepIt = true;
						$if SCORE_RANGE [[
							KeepIt &= (Alignment->Score >= OutputType->ScoreRange[0] && Alignment->Score <= OutputType->ScoreRange[1]);
						]]
						$if CYCLE_RANGE [[ 
							KeepIt &= (Alignment->Cycles >= OutputType->CycleRange[0] && Alignment->Cycles <= OutputType->CycleRange[1]);
						]]
						$if BORDER_CLIP [[
							KeepIt &= Alignment->Region.sequence.Begin >= OutputType->BorderClip[0]
										&& ((Alignment->Region.sequence.End + OutputType->BorderClip[1]) <= SeqLength);
						]]
						
						$if INVERSE_SELECTION [[
							KeepIt = !KeepIt;
						]]
						$if (BORDER_CLIP | SCORE_RANGE | CYCLE_RANGE | INVERSE_SELECTION) [[
							if (KeepIt)
						]] $else [[
							if ((Alignment->Score >= prf->CutOff || OutputType->Specific.Text.OptimalOnly) )
						]]
						{
							if (++count >= AlignmentsMemorySize) {
								AlignmentsMemorySize += 10;
								Alignments = (Alignment_t*) realloc(Alignments, AlignmentsMemorySize*sizeof(Alignment_t));
								if (Alignments == NULL) {
									fprintf(stderr, "Unable to increase alignments'size to %lu\n", AlignmentsMemorySize);
									pthread_exit((void*) 1);
								}
								Alignment = &Alignments[count-1];
							}
						}
					}
				}  while ($if SCORE_RANGE [[ Alignment->Score >= OutputType->ScoreRange[0] ]] $else [[ Alignment->Score >= prf->CutOff ]] );
			]]
			
			/* Sort the Alignments */
			if (count) {
				qsort(Alignments, count, sizeof(Alignment_t), compareAlignments);
				{
					const size_t ThisSeqLength = Alignments[0].Region.sequence.Begin;
					if (ThisSeqLength > 0UL) {
						const unsigned char Backup = SequenceText[ThisSeqLength];
						SequenceText[ThisSeqLength] = '\0';
						const unsigned char * const AlignedSequence = SequenceText;// - 1;
						snprintf(NewHeader, 1024, "%s before %s with score %i", SeqData.Data.Header, prf->Identification, Alignments[0].Score);
						pthread_mutex_lock(PrintLock);
						OutputType->Specific.Text.Print(prf, AlignedSequence, &Alignments[0], NewHeader, ThisSeqLength, 0.0f);
						pthread_mutex_unlock(PrintLock);
						SequenceText[ThisSeqLength] = Backup;
					}
				}
				if (count >= 2) {
					for (unsigned int k=1; k<count; k++) { 
						const ssize_t ThisSeqLength = (ssize_t) Alignments[k].Region.sequence.Begin - (ssize_t) Alignments[k-1].Region.sequence.End - 1;
						if (ThisSeqLength > 0) {
							const unsigned char Backup = SequenceText[Alignments[k].Region.sequence.Begin];
							SequenceText[Alignments[k].Region.sequence.Begin] = '\0';
							const unsigned char * const AlignedSequence = SequenceText + Alignments[k-1].Region.sequence.End + 1;
							snprintf(NewHeader, 1024, "%s/%u/%u-%u in between %s with scores %i and %i", SeqData.Data.Header, k,
											Alignments[k-1].Region.sequence.End + 1, Alignments[k].Region.sequence.Begin - 1,
											prf->Identification, Alignments[k-1].Score, Alignments[k].Score);
							pthread_mutex_lock(PrintLock);
							OutputType->Specific.Text.Print(prf, AlignedSequence, &Alignments[k], NewHeader, (size_t) ThisSeqLength, 0.0f);
							pthread_mutex_unlock(PrintLock);
							SequenceText[Alignments[k].Region.sequence.Begin] = Backup;
						}
					}
				}
				{
					const ssize_t ThisSeqLength = (ssize_t) SeqLength - (ssize_t) Alignments[count-1].Region.sequence.End - 1;
					if (ThisSeqLength > 0L) {
						const unsigned char * const AlignedSequence = SequenceText + Alignments[count-1].Region.sequence.End + 1;
						snprintf(NewHeader, 1024, "%s after %s with score %i", SeqData.Data.Header, prf->Identification, Alignments[count-1].Score);
						pthread_mutex_lock(PrintLock);
						OutputType->Specific.Text.Print(prf, AlignedSequence, &Alignments[count-1], NewHeader, (size_t) ThisSeqLength, 0.0f);
						pthread_mutex_unlock(PrintLock);
					}
				}
			}
		} ]]
		$elif (WRAPPER_TEXT == 1) [[ {
			///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			// SOURCE OUTPUT
			Alignment_t Alignment;
			Alignment.Orientation = 1;
			const Alignment_t * restrict AlignPtr = &Alignment;
			/* Get Best Alignment */
			const size_t OutputSequenceLength = CoreCompute->GetBestAlignment(matrix, &Alignment, SeqLength, prfLength);
			
			if (OutputSequenceLength == 0  && Alignment.Score >= prf->CutOff) {
				fprintf(stderr, "Issue as alignment does not start with an ENTRY point! (score=%i, seqlength=%lu)\n%s\n",
								Alignment.Score, SeqLength,  SequenceText);
			}
			$if WITH_REVERSE [[
				Alignment_t rvAlignment;
				rvAlignment.Orientation = -1;
				/* Get Best Alignment */
				const size_t rvOutputSequenceLength = CoreCompute->GetBestAlignment(rvmatrix, &rvAlignment, SeqLength, prfLength);
				if (rvOutputSequenceLength == 0  && rvAlignment.Score >= prf->CutOff) {
					fprintf(stderr, "Issue as alignment does not start with an ENTRY point! (score=%i, seqlength=%lu)\n%s\n",
									rvAlignment.Score, SeqLength, SequenceText);
				}
				else {
					if (rvAlignment.Score > Alignment.Score) {
						AlignPtr = &rvAlignment;
						PerformRevComp(SequenceText, SeqLength);
					}
				}
			]]
			
			_Bool KeepIt = true;
			$if SCORE_RANGE [[
				KeepIt &= (Alignment.Score >= OutputType->ScoreRange[0] && Alignment.Score <= OutputType->ScoreRange[1]);
			]]
			$if CYCLE_RANGE [[ 
				KeepIt &= (Alignment.Cycles >= OutputType->CycleRange[0] && Alignment.Cycles <= OutputType->CycleRange[1]);
			]]
			$if BORDER_CLIP [[
				KeepIt &= Alignment.Region.sequence.Begin >= OutputType->BorderClip[0]
								&& ((Alignment.Region.sequence.End + OutputType->BorderClip[1]) <= SeqLength);
			]]
			
			$if INVERSE_SELECTION [[
				KeepIt = !KeepIt;
			]]
			$if (BORDER_CLIP | SCORE_RANGE | CYCLE_RANGE | INVERSE_SELECTION) [[
				if (KeepIt)
			]] $else [[
				if (Alignment.Score >= prf->CutOff)
			]]
			{
				pthread_mutex_lock(PrintLock);
				OutputType->Specific.Text.Print(prf, SequenceText, AlignPtr, SeqData.Data.Header, SeqLength, 0.0f );
				pthread_mutex_unlock(PrintLock);
			}
		} ]]
		$elif (WRAPPER_TEXT == 5) [[ {
			///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			// SOURCE OUTPUT
			Alignment_t Alignment;
			Alignment.Orientation = 1;
			const Alignment_t * restrict AlignPtr = &Alignment;
			const union lScores * restrict matrixPtr = matrix;
			/* Get Best Alignment */
			size_t OutputSequenceLength = CoreCompute->GetBestAlignment(matrix, &Alignment, SeqLength, prfLength);
			
			if (OutputSequenceLength == 0  && Alignment.Score >= prf->CutOff) {
				fprintf(stderr, "Issue as alignment does not start with an ENTRY point! (score=%i, seqlength=%lu)\n%s\n",
								Alignment.Score, SeqLength,  SequenceText);
			}
			Alignment_t rvAlignment;
			rvAlignment.Orientation = -1;
			/* Get Best Alignment */
			const size_t rvOutputSequenceLength = CoreCompute->GetBestAlignment(rvmatrix, &rvAlignment, SeqLength, prfLength);
			if (rvOutputSequenceLength == 0  && rvAlignment.Score >= prf->CutOff) {
				fprintf(stderr, "Issue as alignment does not start with an ENTRY point! (score=%i, seqlength=%lu)\n%s\n",
								rvAlignment.Score, SeqLength, SequenceText);
			}
			else {
				if (rvAlignment.Score > Alignment.Score) {
					AlignPtr = &rvAlignment;
					OutputSequenceLength = rvOutputSequenceLength;
					matrixPtr = rvmatrix;
				}
			}
			
			_Bool KeepIt = true;
			$if SCORE_RANGE [[
				KeepIt &= (Alignment.Score >= OutputType->ScoreRange[0] && Alignment.Score <= OutputType->ScoreRange[1]);
			]]
			$if CYCLE_RANGE [[ 
				KeepIt &= (Alignment.Cycles >= OutputType->CycleRange[0] && Alignment.Cycles <= OutputType->CycleRange[1]);
			]]
			$if BORDER_CLIP [[
				KeepIt &= Alignment.Region.sequence.Begin >= OutputType->BorderClip[0]
								&& ((Alignment.Region.sequence.End + OutputType->BorderClip[1]) <= SeqLength);
			]]
			
			$if INVERSE_SELECTION [[
				KeepIt = !KeepIt;
			]]
			
			if (KeepIt) {
				if (AlignPtr->Orientation < 0) {
					PerformRevComp(SequenceText, SeqLength);
				}
				/* Get Aligned Sequence */
				if (OutputSequenceLength > OutputSequenceMemorySize) {
					OutputSequenceMemorySize = OutputSequenceLength; 
					OutputSequence = (unsigned char*) realloc(OutputSequence, OutputSequenceMemorySize*sizeof(unsigned char));
					if (OutputSequence == NULL) {
						fputs("Unable to allocate memory\n", stderr);
						exit(1);
					}
				}
				
				CoreCompute->GetAlignmentSequence(matrixPtr, SequenceText, OutputSequence, AlignPtr, SeqLength, prfLength);
				
				pthread_mutex_lock(PrintLock);
				OutputType->Specific.Text.Print(prf, OutputSequence, AlignPtr, SeqData.Data.Header, OutputSequenceLength, 0.0f );
				pthread_mutex_unlock(PrintLock);
			}
		} ]]

	}
	
	/////////////////////////////////////////////////////////////////////////////////////////////////////////
	//SUMMARIZE;
	((struct ThreadData*) _Data)->counter = AlignedSeqCounter;
	
END:;

	/* close sequence file */
	UNSET_DATABASE_ACCESS();

	/* Free Memory */
	free(SeqData.Data.Memory);
	_mm_free(WORK);
	_mm_free(matrix);
	$if WITH_REVERSE  [[ _mm_free(rvmatrix); ]]
	$if (WRAPPER_TEXT == 1) [[ ]] $else [[ free(HasAPath); ]]
	$if ((WRAPPER_TEXT == 0)|(WRAPPER_TEXT == 5)) [[ free(OutputSequence); ]]
	$if (WRAPPER_TEXT == 4) [[ free(BackupSequence); ]]
	free(SequenceText);
	pthread_exit((void*) NULL);
}
]]
]] ]] ]] ]] ]]
]]

/****************************************************************************************************
 * MATRIX PROFILES: HISTOGRAM
 */
$for HISTO_CYCLE [[
$for CYCLE_RANGE [[ $for SCORE_RANGE [[ $for BORDER_CLIP [[ $for WITH_REVERSE [[
$if (SCORE_RANGE | (HISTO_CYCLE & CYCLE_RANGE)) [[

static
THREAD_FUNCTION(tfaph$HISTO_CYCLE$BORDER_CLIP$CYCLE_RANGE$SCORE_RANGE$WITH_REVERSE)
{
	$if WITH_REVERSE [[
		unsigned char RevComp_Index_Mapping[ALPHABET_SIZE+2] __attribute__((aligned(16)));	
	]]
	
	Sequence_t SeqData;
	
	/*************************************************************************/
  /*                          GET COMMON DATA                              */
  /*************************************************************************/
	const FASTAStructure * const restrict FASTA = ((struct ThreadData*) _Data)->FASTA;
	const unsigned int * const restrict SeqID = ((struct ThreadData*) _Data)->SequenceID;
	pthread_mutex_t * const restrict PrintLock = ((struct ThreadData*) _Data)->PrintLock;
	
	/* For profile search we need to have */
	const struct Profile * const restrict prf = ((struct ThreadData*) _Data)->prf;
	const Compute_t * const restrict CoreCompute = ((struct ThreadData*) _Data)->Compute;
	
	/* For output we need */
	$if HISTO_CYCLE [[
		const unsigned short int range[2] = { (((struct ThreadData*) _Data)->OutputType)->CycleRange[0], 
		                                      (((struct ThreadData*) _Data)->OutputType)->CycleRange[1] }; 
		$if SCORE_RANGE [[
			const int ScoreRange[2] = { (((struct ThreadData*) _Data)->OutputType)->ScoreRange[0],
																	(((struct ThreadData*) _Data)->OutputType)->ScoreRange[1] };
		]]
	]] $else [[
		const int range[2] = { (((struct ThreadData*) _Data)->OutputType)->ScoreRange[0],
													 (((struct ThreadData*) _Data)->OutputType)->ScoreRange[1] };
		$if CYCLE_RANGE [[
				const unsigned int CycleRange[2] = { (((struct ThreadData*) _Data)->OutputType)->CycleRange[0], 
		                                         (((struct ThreadData*) _Data)->OutputType)->CycleRange[1] };
		]]
	]]
	
	$if BORDER_CLIP [[
		unsigned short int  BorderClip[2] =  { (((struct ThreadData*) _Data)->OutputType)->BorderClip[0],
													                 (((struct ThreadData*) _Data)->OutputType)->BorderClip[1] };
	
	]]
	/*************************************************************************/
	/*                          ALLOCATE MEMORY                              */
	/*************************************************************************/
	/* Allocate memory to hold sequence */
	SeqData.Data.Memory = malloc(FASTA->MaxSequenceSize*sizeof(unsigned char));
	if (SeqData.Data.Memory == NULL) {
		fputs("Thread cannot allocate memory for sequence.\n", stderr);
		pthread_exit((void*)1);
	}
	
	/* Allocate work aligned memory for xali1 */
	size_t matrixLD = prf->Length+1;
	union lScores * const restrict matrix = _mm_malloc(matrixLD*FASTA->MaxSequenceSize*sizeof(union lScores), 64);
	$if WITH_REVERSE [[
		union lScores * const restrict rvmatrix = _mm_malloc(matrixLD*FASTA->MaxSequenceSize*sizeof(union lScores), 64);
	]]
	int * const restrict WORK = _mm_malloc(GetWorkArraySize(prf, CoreCompute),64);
	if ( $if WITH_REVERSE [[ rvmatrix == NULL || ]] matrix == NULL || WORK == NULL ) {
		if (WORK) _mm_free(WORK);
		if (matrix) _mm_free(matrix);
		$if WITH_REVERSE  [[ if (rvmatrix) _mm_free(rvmatrix); ]]
		free(SeqData.Data.Memory);
		pthread_exit((void*)1);
	}
	
	/*************************************************************************/
	/*                          CONFIGURE WORKER                             */
	/*************************************************************************/
	$if WITH_REVERSE  [[ 
		for (unsigned char a=0;a<ALPHABET_SIZE+2; a++) RevComp_Index_Mapping[a] = a;
		{
			unsigned char c;
			c = RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'A' - (int) 'A' ] ];
			RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'A' - (int) 'A' ] ] = RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'T' - (int) 'A' ] ];
			RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'T' - (int) 'A' ] ] = c;
		}
		{
			unsigned char c;
			c = RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'C' - (int) 'A' ] ];
			RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'C' - (int) 'A' ] ] = RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'G' - (int) 'A' ] ];
			RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'G' - (int) 'A' ] ] = c;
		}
	]]
	
	
	/* Open sequence file */
	SETUP_DATABASE_ACCESS(FASTA->SequenceFile);

	const size_t Start = ((struct ThreadData*) _Data)->start;
	const size_t Stop  = ((struct ThreadData*) _Data)->stop;
	const size_t prfLength = prf->Length;
	
	/////////////////////////////////////////////////////////////////////////////////////////////////////////
	//DECLARED_VARIABLES
	
	size_t Missed = 0UL;
	size_t * const restrict Histogram = ((struct ThreadData*) _Data)->Histogram;
	
	/*****************************************************************/
	/*                    LOOPS ON SEQUENCES                         */
	/*****************************************************************/
	for (size_t i=Start; i<Stop; ++i) {
		PFSequence * PFSeq = GET_DATABASE_SEQUENCE(&SeqData, FASTA->DataPtr, i);

		/* Translate first sequence */
		PFSeq = TranslateSequenceToIndex(PFSeq, prf->Alphabet_Mapping);
		CoreCompute->BuildMatrix(prf, PFSeq->ProfileIndex, matrix, WORK, NULL, 0, PFSeq->Length);
		
		$if WITH_REVERSE [[ 
			RevCompIndex(PFSeq, RevComp_Index_Mapping);
			CoreCompute->BuildMatrix(prf, PFSeq->ProfileIndex, rvmatrix, WORK, NULL, 0, PFSeq->Length);
		]]
		
		
		/////////////////////////////////////////////////////////////////////////////////////////////////////////
		// WORK_ON_MATRICES;
		/**************************************** Histogram **************************************************/
		$if CYCLE_RANGE [[ {
			ScoreCycle_t SC $if WITH_REVERSE [[ , rvSC ]] ;
			GetBestScoreAndCycles(matrix, PFSeq->Length, prfLength, &SC);

			$if WITH_REVERSE [[ GetBestScoreAndCycles(rvmatrix, PFSeq->Length, prfLength, &rvSC); ]]
			$if BORDER_CLIP [[
				if ((SC.Begin <= BorderClip[0]) || (SC.End+BorderClip[1] >= PFSeq->Length)) {
					$if SCORE_RANGE [[ SC.Score = NLOW; ]]
					$if CYCLE_RANGE [[ SC.Cycles = 0; ]]
				}
			]]
			$if (HISTO_CYCLE & SCORE_RANGE) [[
				if (SC.Score < ScoreRange[0] || SC.Score > ScoreRange[1]) {
					SC.Cycles = 0;
				}
				$if WITH_REVERSE [[
					if (rvSC.Score < ScoreRange[0] || rvSC.Score > ScoreRange[1]) {
						rvSC.Cycles = 0;
					}
				]]
			]]
			$if (CYCLE_RANGE & ~(HISTO_CYCLE)) [[
				if (SC.Cycles < CycleRange[0] || SC.Cycles > CycleRange[1]) {
					SC.Score = NLOW;
				}
				$if WITH_REVERSE [[
					if (rvSC.Cycles < CycleRange[0] || rvSC.Cycles > CycleRange[1]) {
						rvSC.Score = NLOW;
					}
				]]
			]]
			
			$if WITH_REVERSE [[
				$if BORDER_CLIP [[
					if ((rvSC.Begin <= BorderClip[0]) || (rvSC.End+BorderClip[1] >= PFSeq->Length)) {
						$if SCORE_RANGE [[ rvSC.Score = NLOW; ]]
						$if CYCLE_RANGE [[ rvSC.Cycles = 0; ]]
					}
				]]
				$if HISTO_CYCLE [[
					if (rvSC.Cycles > SC.Cycles) SC.Cycles = rvSC.Cycles;
				]] $else [[
					if (rvSC.Score > SC.Score) SC.Score = rvSC.Score;
				]]
			]]
			
			$if HISTO_CYCLE [[
				if (SC.Cycles >= range[0] && SC.Cycles <= range[1]) {
					Histogram[SC.Cycles-range[0] ]++;
				}
				else 
					Missed++;
			]]
			$else [[
				if (SC.Score >= range[0] && SC.Score <= range[1]) {
					Histogram[SC.Score-range[0] ]++;
				}
				else 
					Missed++;
			]]
		} ]]
		$else [[ {
			$if BORDER_CLIP [[
				Alignment_t Alignment;
				CoreCompute->GetBestAlignment(matrix, &Alignment, PFSeq->Length, prfLength);
				if ( (Alignment.Region.sequence.Begin <= BorderClip[0]) 
					|| (Alignment.Region.sequence.End+BorderClip[1] >= PFSeq->Length)) {
					Alignment.Score = NLOW;
				}
				$if WITH_REVERSE [[
					Alignment_t rvAlignment;
					CoreCompute->GetBestAlignment(rvmatrix, &rvAlignment, PFSeq->Length, prfLength);
					if ( (rvAlignment.Region.sequence.Begin <= BorderClip[0]) 
						|| (rvAlignment.Region.sequence.End+BorderClip[1] >= PFSeq->Length)) {
						rvAlignment.Score = NLOW;
					}
					else {
						if (rvAlignment.Score > Alignment.Score) Alignment.Score = rvAlignment.Score;
					}
				]]
				if (Alignment.Score >= range[0] && Alignment.Score <= range[1])
					Histogram[Alignment.Score-range[0] ]++;
				else
					Missed++;
			]]
			$else [[
				int Score = CoreCompute->GetBestScore(matrix, PFSeq->Length, prfLength);
				$if WITH_REVERSE [[
					const int rvScore = CoreCompute->GetBestScore(rvmatrix, PFSeq->Length, prfLength);
					if (rvScore > Score) Score = rvScore;
				]]
				if (Score >= range[0] && Score <= range[1]) {
					Histogram[Score-range[0] ]++;
				}
				else 
					Missed++;
				]]
		} ]]
	}
	
	/////////////////////////////////////////////////////////////////////////////////////////////////////////
	//SUMMARIZE;
	((struct ThreadData*) _Data)->counter = Missed;
	
END:;

	/* close sequence file */
	UNSET_DATABASE_ACCESS();

	/* Free Memory */
	free(SeqData.Data.Memory);
	_mm_free(WORK);
	_mm_free(matrix);
	$if WITH_REVERSE  [[ _mm_free(rvmatrix); ]]
	pthread_exit(0);
}

]]
]] ]] ]] ]]
]]

/****************************************************************************************************
 * MATRIX PROFILES: DENSITY
 */
$for WITH_REVERSE [[

static
THREAD_FUNCTION(tfapd$WITH_REVERSE)
{
	$if WITH_REVERSE [[
		unsigned char RevComp_Index_Mapping[ALPHABET_SIZE+2] __attribute__((aligned(16)));	
	]]
	
	Sequence_t SeqData;
	const FASTAStructure * const restrict FASTA = ((struct ThreadData*) _Data)->FASTA;
	const unsigned int * const restrict SeqID = ((struct ThreadData*) _Data)->SequenceID;
	pthread_mutex_t * const restrict PrintLock = ((struct ThreadData*) _Data)->PrintLock;
	PFSequence * PFSeq;
	
	/* For profile search we need to have */
	const struct Profile * const restrict prf = ((struct ThreadData*) _Data)->prf;
	const Compute_t * const restrict CoreCompute = ((struct ThreadData*) _Data)->Compute;
	
	/* Allocate memory to hold sequence */
	unsigned char * restrict SequenceText = malloc(FASTA->MaxSequenceSize*sizeof(unsigned char));
	SeqData.Data.Memory = malloc(FASTA->MaxSequenceSize*sizeof(unsigned char));
	if (SeqData.Data.Memory == NULL || SequenceText == NULL) {
		fputs("Thread cannot allocate memory for sequence.\n", stderr);
		pthread_exit((void*)1);
	}

	/* Allocate work aligned memory for xali1 */
	size_t matrixLD = prf->Length+1;
	union lScores * const restrict matrix = _mm_malloc(matrixLD*FASTA->MaxSequenceSize*sizeof(union lScores), 64);
	$if WITH_REVERSE [[
	union lScores * const restrict rvmatrix = _mm_malloc(matrixLD*FASTA->MaxSequenceSize*sizeof(union lScores), 64);
	]]
	int * const restrict WORK = _mm_malloc(GetWorkArraySize(prf, CoreCompute),64);
	if ( $if WITH_REVERSE [[ rvmatrix == NULL || ]] matrix == NULL || WORK == NULL ) {
		if (WORK) _mm_free(WORK);
		if (matrix) _mm_free(matrix);
		$if WITH_REVERSE  [[ if (rvmatrix) _mm_free(rvmatrix); ]]
		free(SeqData.Data.Memory);
		free(SequenceText);
		pthread_exit((void*)1);
	}
	
	$if WITH_REVERSE  [[ 
		for (unsigned char a=0;a<ALPHABET_SIZE+2; a++) RevComp_Index_Mapping[a] = a;
		{
			unsigned char c;
			c = RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'A' - (int) 'A' ] ];
			RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'A' - (int) 'A' ] ] = RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'T' - (int) 'A' ] ];
			RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'T' - (int) 'A' ] ] = c;
		}
		{
			unsigned char c;
			c = RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'C' - (int) 'A' ] ];
			RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'C' - (int) 'A' ] ] = RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'G' - (int) 'A' ] ];
			RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'G' - (int) 'A' ] ] = c;
		}
	]]
	
	const unsigned short int CycleRange[2] = { (((struct ThreadData*) _Data)->OutputType)->CycleRange[0], 
	                                           (((struct ThreadData*) _Data)->OutputType)->CycleRange[1] }; 
	const int ScoreRange[2] = { (((struct ThreadData*) _Data)->OutputType)->ScoreRange[0],
	                            (((struct ThreadData*) _Data)->OutputType)->ScoreRange[1] };
	
	/* Open sequence file */
	SETUP_DATABASE_ACCESS(FASTA->SequenceFile);

	const size_t Start = ((struct ThreadData*) _Data)->start;
	const size_t Stop  = ((struct ThreadData*) _Data)->stop;

	const int CutOff = prf->CutOff;
	const size_t prfLength = prf->Length;
	
	/****************************************** Density **************************************************/
	size_t Missed = 0UL;
	size_t * const restrict Histogram = ((struct ThreadData*) _Data)->Histogram;
	const size_t Density_LD = CycleRange[1] - CycleRange[0] + 1;
	
	/* LOOPS ON SEQUENCES */
	for (size_t i=Start; i<Stop; ++i) {
		PFSeq = GET_DATABASE_SEQUENCE(&SeqData, FASTA->DataPtr, i);

		/* Copy sequence to SequenceText */
		const size_t SeqLength = CleanSequenceTo(SequenceText, PFSeq->ProfileIndex, PFSeq->Length);
		
		/* Translate first sequence */
		PFSeq = TranslateSequenceToIndex(PFSeq, prf->Alphabet_Mapping);
		CoreCompute->BuildMatrix(prf, PFSeq->ProfileIndex, matrix, WORK, NULL, 0, SeqLength);
		
		$if WITH_REVERSE  [[ 
			RevCompIndex(PFSeq, RevComp_Index_Mapping);
			CoreCompute->BuildMatrix(prf, PFSeq->ProfileIndex, rvmatrix, WORK, NULL, 0, SeqLength);
		]]
		
		
		/////////////////////////////////////////////////////////////////////////////////////////////////////////
		// WORK_ON_MATRICES;
		ScoreCycle_t SC $if WITH_REVERSE [[, rvSC]];
		GetBestScoreAndCycles(matrix, SeqLength, prfLength, &SC);
		$if WITH_REVERSE [[
			GetBestScoreAndCycles(rvmatrix, SeqLength, prfLength, &rvSC);
			int Score = (rvSC.Score > SC.Score) ? rvSC.Score : SC.Score;
			unsigned int Cycles = (rvSC.Score > SC.Score) ? rvSC.Cycles : SC.Cycles;
			if (Score>=ScoreRange[0] && Score<ScoreRange[1] && Cycles>=CycleRange[0] && Cycles<CycleRange[1]) {
				const size_t index = Score - ScoreRange[0];
				Histogram[index*Density_LD+Cycles-CycleRange[0] ]++;
			}
			else {
				Missed++;
			}
		]] $else [[
			if (SC.Score>=ScoreRange[0] && SC.Score<ScoreRange[1] && SC.Cycles>=CycleRange[0] && SC.Cycles<CycleRange[1]) {
				const size_t index = SC.Score - ScoreRange[0];
				Histogram[index*Density_LD+SC.Cycles-CycleRange[0] ]++;
			}
			else {
				Missed++;
			}
		]]
	}
	
	/////////////////////////////////////////////////////////////////////////////////////////////////////////
	//SUMMARIZE;
	((struct ThreadData*) _Data)->counter = Missed;
	
END:;

	/* close sequence file */
	UNSET_DATABASE_ACCESS();

	/* Free Memory */
	free(SeqData.Data.Memory);
	_mm_free(WORK);
	_mm_free(matrix);
	$if WITH_REVERSE  [[ _mm_free(rvmatrix); ]]
	free(SequenceText);
	pthread_exit(0);
}

]]

/****************************************************************************************************
 * MATRIX PROFILES: OTHER
 */
$for WITH_REVERSE [[

static
THREAD_FUNCTION(tfapo$WITH_REVERSE)
{
	$if WITH_REVERSE [[
	unsigned char RevComp_Index_Mapping[ALPHABET_SIZE+2] __attribute__((aligned(16)));	
	]]
	
	Sequence_t SeqData;
	PFSequence * PFSeq;
	/*************************************************************************/
	/*                          GET COMMON DATA                              */
	/*************************************************************************/
	const FASTAStructure * const restrict FASTA = ((struct ThreadData*) _Data)->FASTA;
	const unsigned int * const restrict SeqID = ((struct ThreadData*) _Data)->SequenceID;
	
	/* For profile search we need to have */
	const struct Profile * const restrict prf = ((struct ThreadData*) _Data)->prf;
	const Compute_t * const restrict CoreCompute = ((struct ThreadData*) _Data)->Compute;
	
	/* For output we need */
	OutputMethod Output = (((struct ThreadData*) _Data)->OutputType)->OutputFct;
	pthread_mutex_t * const restrict PrintLock = ((struct ThreadData*) _Data)->PrintLock;
	const void * const OutputMethodOptions = &((((struct ThreadData*) _Data)->OutputType)->Specific);
	
	/*************************************************************************/
	/*                          ALLOCATE MEMORY                              */
	/*************************************************************************/
	/* Allocate memory to hold sequence */
	unsigned char * restrict SequenceText = malloc(FASTA->MaxSequenceSize*sizeof(unsigned char));
	SeqData.Data.Memory = malloc(FASTA->MaxSequenceSize*sizeof(unsigned char));
	if (SeqData.Data.Memory == NULL || SequenceText == NULL) {
		fputs("Thread cannot allocate memory for sequence.\n", stderr);
		pthread_exit((void*)1);
	}

	/* Allocate work aligned memory for xali1 */
	size_t matrixLD = prf->Length+1;
	union lScores * const restrict matrix = _mm_malloc(matrixLD*FASTA->MaxSequenceSize*sizeof(union lScores), 64);
	$if WITH_REVERSE [[
	union lScores * const restrict rvmatrix = _mm_malloc(matrixLD*FASTA->MaxSequenceSize*sizeof(union lScores), 64);
	]]
	int * const restrict WORK = _mm_malloc(GetWorkArraySize(prf, CoreCompute),64);
	if ( $if WITH_REVERSE [[ rvmatrix == NULL || ]] matrix == NULL || WORK == NULL ) {
		if (WORK) _mm_free(WORK);
		if (matrix) _mm_free(matrix);
		$if WITH_REVERSE  [[ if (rvmatrix) _mm_free(rvmatrix); ]]
		free(SeqData.Data.Memory);
		free(SequenceText);
		pthread_exit((void*)1);
	}
	
	/*************************************************************************/
	/*                          CONFIGURE WORKER                             */
	/*************************************************************************/
	$if WITH_REVERSE  [[ 
		for (unsigned char a=0;a<ALPHABET_SIZE+2; a++) RevComp_Index_Mapping[a] = a;
		{
			unsigned char c;
			c = RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'A' - (int) 'A' ] ];
			RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'A' - (int) 'A' ] ] = RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'T' - (int) 'A' ] ];
			RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'T' - (int) 'A' ] ] = c;
		}
		{
			unsigned char c;
			c = RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'C' - (int) 'A' ] ];
			RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'C' - (int) 'A' ] ] = RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'G' - (int) 'A' ] ];
			RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'G' - (int) 'A' ] ] = c;
		}
	]]
	
	
	
	/* Open sequence file */
	SETUP_DATABASE_ACCESS(FASTA->SequenceFile);

	const size_t Start = ((struct ThreadData*) _Data)->start;
	const size_t Stop  = ((struct ThreadData*) _Data)->stop;

	const int CutOff = prf->CutOff;
	const size_t prfLength = prf->Length;
		
	/* LOOPS ON SEQUENCES */
	for (size_t i=Start; i<Stop; ++i) {
		PFSeq = GET_DATABASE_SEQUENCE(&SeqData, FASTA->DataPtr, i);

		/* Copy sequence to SequenceText */
		const size_t SeqLength = CleanSequenceTo(SequenceText, PFSeq->ProfileIndex, PFSeq->Length);
		
		/* Translate first sequence */
		PFSeq = TranslateSequenceToIndex(PFSeq, prf->Alphabet_Mapping);
		CoreCompute->BuildMatrix(prf, PFSeq->ProfileIndex, matrix, WORK, NULL, 0, SeqLength);
		
		$if WITH_REVERSE  [[ 
			RevCompIndex(PFSeq, RevComp_Index_Mapping);
			CoreCompute->BuildMatrix(prf, PFSeq->ProfileIndex, rvmatrix, WORK, NULL, 0, SeqLength);
		]]
		
		
		/////////////////////////////////////////////////////////////////////////////////////////////////////////
		// WORK_ON_MATRICES;
		Output(matrix, $if WITH_REVERSE [[ rvmatrix ]] $else [[ NULL ]], SequenceText, SeqData.Data.Header,
		       prf, CoreCompute, SeqLength, OutputMethodOptions, PrintLock);

	}
		
END:;

	/* close sequence file */
	UNSET_DATABASE_ACCESS();

	/* Free Memory */
	free(SeqData.Data.Memory);
	_mm_free(WORK);
	_mm_free(matrix);
	$if WITH_REVERSE  [[ _mm_free(rvmatrix); ]]
	free(SequenceText);
	pthread_exit(0);
}

]]


#if defined(USE_PCRE)

$for WITH_REVERSE [[
static
THREAD_FUNCTION(tfar0$WITH_REVERSE) {}
// {
// 	Sequence_t SeqData;
// 	const struct RegEx * const restrict regex   = ((struct ThreadData*) _Data)->regex;
// 	const FASTAStructure * const restrict FASTA = ((struct ThreadData*) _Data)->FASTA;
// 	size_t * const restrict Histogram           = ((struct ThreadData*) _Data)->Histogram;
// 	PFSequence * PFSeq;
// 	
// 	/* Allocate memory to hold sequence */
// 	SeqData.Data.Memory = malloc(FASTA->MaxSequenceSize*sizeof(unsigned char));
// 	if (SeqData.Data.Memory == NULL) {
// 		fputs("Thread Cannot allocate memory for sequence.\n", stderr);
// 		pthread_exit((void*) 1);
// 	}
// 	
// 	/* Allocate the memory to hold the matches */
// 	const size_t nmatch = regex->maxMatchCount;
// 	int * Matches = (int*) malloc(2*(1+nmatch)*sizeof(int));
// 
// 	if (Matches == NULL) {
// 		fputs("Thread Cannot allocate memory for regex match structure.\n", stderr);
// 		pthread_exit((void*) 1);
// 	}
// 	
// 	/* Open sequence file*/
// 	SETUP_DATABASE_ACCESS(FASTA->SequenceFile);
// 	
// 	size_t Start  = ((struct ThreadData*) _Data)->start;
// 	size_t Stop   = ((struct ThreadData*) _Data)->stop;
// 	
// 	/*
// 	 *  SEARCH IN SEQUENCE
// 	 */
// 	size_t Missed=0;
// 	const pcre * const restrict rg = regex->regexCompiled[0];
// 
// 	
// 	/* LOOPS ON SEQUENCES */
// 	for (size_t i=Start; i<Stop; ++i) {
// 		PFSeq = GET_DATABASE_SEQUENCE(&SeqData, FASTA->DataPtr, i);
// 		
// 		/* Translate first sequence */
// 		const char * const CleanSeq = CleanSequence(PFSeq);
// 		
// 		/* Run the regex engine */
// 
// 		int ovector[2*8];
// 		unsigned int offset = 0;
// 		const unsigned int len = PFSeq->Length;
// 		int rc;
// 		size_t count = 0;
// 		while (offset < len && (rc = pcre_exec(rg, 0, CleanSeq, len, offset, 0, ovector, 16)) >= 0)
// 		{
// 			count += rc;
// 			offset = ovector[1];
// 		}
// 		
// 		$if WITH_REVERSE [[
// 		ReverseComplementSequence(PFSeq);
// 		offset = 0;
// 		size_t rccount = 0;
// 		
// 		while (offset < len && (rc = pcre_exec(rg, 0, CleanSeq, len, offset, 0, ovector, 16)) >= 0)
// 		{
// 			rccount += rc;
// 			offset = ovector[1];
// 		}
// 		
// 		count = (rccount > count) ? rccount : count;
// 		]]
// 		
// 		if (count < HistogramSize)
// 			Histogram[count]++;
// 		else
// 			Missed++;
// 	}
// 
// 	((struct ThreadData*) _Data)->counter = (unsigned long) Missed;
// 	
// 	/* close sequence file */
// 	UNSET_DATABASE_ACCESS();
// 	
// 	/* Free Memory */
// 	free(SeqData.Data.Memory);
// 	free(Matches);
// 	pthread_exit(0);
// };

THREAD_FUNCTION(tfar1$WITH_REVERSE) {}
// {
// 	Sequence_t SeqData;
// 	const struct RegEx * const restrict regex   = ((struct ThreadData*) _Data)->regex;
// 	const FASTAStructure * const restrict FASTA = ((struct ThreadData*) _Data)->FASTA;
// 	size_t * const restrict Histogram           = ((struct ThreadData*) _Data)->Histogram;
// 	PFSequence * PFSeq;
// 	
// 	/* Allocate memory to hold sequence */
// 	SeqData.Data.Memory = malloc(FASTA->MaxSequenceSize*sizeof(unsigned char));
// 	if (SeqData.Data.Memory == NULL) {
// 		fputs("Thread Cannot allocate memory for sequence.\n", stderr);
// 		pthread_exit((void*) 1);
// 	}
// 	
// 	/* Allocate the memory to hold the matches */
// 	const size_t nmatch = regex->maxMatchCount;
// 	int * Matches = (int*) malloc(2*(1+nmatch)*sizeof(int));
// 
// 	if (Matches == NULL) {
// 		fputs("Thread Cannot allocate memory for regex match structure.\n", stderr);
// 		pthread_exit((void*) 1);
// 	}
// 	
// 	/* Open sequence file*/
// 	SETUP_DATABASE_ACCESS(FASTA->SequenceFile);
// 	
// 	size_t Start  = ((struct ThreadData*) _Data)->start;
// 	size_t Stop   = ((struct ThreadData*) _Data)->stop;
// 	
// 	/*
// 	 *  SEARCH IN SEQUENCE
// 	 */
// 	size_t Missed=0;
// 	
// 	/* LOOPS ON SEQUENCES */
// 	for (size_t i=Start; i<Stop; ++i) {
// 		PFSeq = GET_DATABASE_SEQUENCE(&SeqData, FASTA->DataPtr, i);
// 		
// 		/* Translate first sequence */
// 		const char * const CleanSeq = CleanSequence(PFSeq);
// 		
// 		/* Run the regex engines */
// 
// 		int ovector[3*8];
// 		const unsigned int len = PFSeq->Length;
// 		size_t CycleCount = 0;
// 		while (CycleCount < HistogramSize) {
// 			unsigned int offset = 0;
// 			const int rc = pcre_exec(regex->regexCompiled[CycleCount], 0, CleanSeq, len, offset, 0, ovector, 8);
// 			if (rc < 0 /* == PCRE_ERROR_NOMATCH*/) break;
// 			++CycleCount;
// 		}
// 		
// 		$if WITH_REVERSE [[
// 		ReverseComplementSequence(PFSeq);
// 		size_t rcCycleCount = 0;
// 		while (rcCycleCount < HistogramSize) {
// 			unsigned int offset = 0;
// 			const int rc = pcre_exec(regex->regexCompiled[rcCycleCount], 0, CleanSeq, len, offset, 0, ovector, 8);
// 			if (rc < 0 /* == PCRE_ERROR_NOMATCH*/) break;
// 			++rcCycleCount;
// 		}
// 		
// 		CycleCount = (rcCycleCount > CycleCount) ? rcCycleCount : CycleCount;
// 		]]
// 		
// 		if (CycleCount < HistogramSize)
// 			Histogram[CycleCount]++;
// 		else
// 			Missed++;
// 	}
// 
// 	((struct ThreadData*) _Data)->counter = (unsigned long) Missed;
// 	
// 	/* close sequence file */
// 	UNSET_DATABASE_ACCESS();
// 	
// 	/* Free Memory */
// 	free(SeqData.Data.Memory);
// 	free(Matches);
// 	pthread_exit(0);
// };

	
]]

#endif

static THREAD_FUNCTION((*lt_fap[])) = {
$for WRAPPER_TEXT [[
$for BORDER_CLIP [[ $for INVERSE_SELECTION [[ $for CYCLE_RANGE [[ $for SCORE_RANGE [[ $for WITH_REVERSE [[
$if ((WRAPPER_TEXT < 5) | WITH_REVERSE) [[
	tfaps$WRAPPER_TEXT$BORDER_CLIP$INVERSE_SELECTION$CYCLE_RANGE$SCORE_RANGE$WITH_REVERSE,
]]
]] ]] ]] ]] ]]
]]

$for HISTO_CYCLE [[
$for CYCLE_RANGE [[ $for SCORE_RANGE [[ $for BORDER_CLIP [[ $for WITH_REVERSE [[
$if ((SCORE_RANGE & ~(HISTO_CYCLE)) | (HISTO_CYCLE & CYCLE_RANGE)) [[
	tfaph$HISTO_CYCLE$BORDER_CLIP$CYCLE_RANGE$SCORE_RANGE$WITH_REVERSE,

]]
]] ]] ]] ]]
]]

$for WITH_REVERSE [[
	tfapd$WITH_REVERSE,
]]


$for WITH_REVERSE [[
	tfapo$WITH_REVERSE,
]]


	0
};
THREAD_FUNCTION((* * t_fap)) = lt_fap;

#if defined(USE_PCRE)
static THREAD_FUNCTION((*lt_far[])) = {
	$for WITH_REVERSE [[
	tfar0$WITH_REVERSE,
	tfar1$WITH_REVERSE,
		
	]]
	0
};

THREAD_FUNCTION((* * t_far)) = lt_far;

#endif
