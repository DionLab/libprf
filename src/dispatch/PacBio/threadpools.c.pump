#include "prf_config.h"
#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>
#include <assert.h>
#define __USE_INLINE_FUNCTIONS__
#include "pfSequence.h"
#include "pfOutput.h"
#include "pb_common.h"
#include "pb_threads.h"
/****************************************************************************************************
 * From the following enums, we define the ordering as follow
 * 
enum SearchType { PRF=1, REGEX=2 };
enum OutputType { TEXT, HISTOGRAM, DENSITY, PNG, DATA, PDF };
enum Constrain { WITH_REVERSE=1, SCORE_RANGE=2, CYCLE_RANGE=4, INVERSE_SELECTION=8, BORDER_CLIP=16};
enum WrapperRange { Wrapper_Alignement = 0, Wrapper_Source = 1, Wrapper_Before = 2, Wrapper_After = 3,
	                  Wrapper_Outer = 4};

	MATRIX PRF:
		TEXT:																								: 160 cases
			- WITH_REVERSE
			- SCORE_RANGE
			- CYCLE_RANGE if circular profile only
			- INVERSE_SELECTION
			- BORDER_CLIP
			- WRAPPER (5 cases)
			
		HISTOGRAM:																					:  4 cases
			- WITH_REVERSE
			- SCORE_RANGE 
			- CYCLE_RANGE if circular profile only
			
		DENSITY: if circular profile												:  2 cases
			- WITH_REVERSE
			- SCORE_RANGE required anyway
			- CYCLE_RANGE required anyway
	
		PDF, PNG, DATA:																			: 2 cases
			- WITH_REVERSE
	
	
	REGEX or PATTERN PRF:
		TEXT:																								: 32 cases
			- WITH_REVERSE
			- SCORE_RANGE
			- CYCLE_RANGE
			- INVERSE_SELECTION
			- BORDER_CLIP
		
		HISTOGRAM:																					:  6 cases
			- WITH_REVERSE
			- SCORE_RANGE 
			- CYCLE_RANGE if circular profile only
			
		DENSITY:																						:  2 cases
			- WITH_REVERSE
			- SCORE_RANGE required anyway
			- CYCLE_RANGE required anyway
**************************************************************************************************** */

$range WITH_REVERSE 0..1
$range SCORE_RANGE 0..1
$range CYCLE_RANGE 0..1
$range HISTO_CYCLE 0..1
$range INVERSE_SELECTION 0..1
$range BORDER_CLIP 0..1
$range WRAPPER_TEXT 0..5

/****************************************************************************************************
 * External dependencies
 */
extern int compareAlignments(const void *a, const void *b);
char *RegionTypeName[] = { "Adapter", "Insert", "HQRegion", "Useless" };

/****************************************************************************************************
 * MATRIX PROFILES: TEXT
 */

$for WRAPPER_TEXT [[
$for BORDER_CLIP [[ $for INVERSE_SELECTION [[ $for CYCLE_RANGE [[ $for SCORE_RANGE [[ $for WITH_REVERSE [[
$if ((WRAPPER_TEXT < 5) | WITH_REVERSE) [[ 

static
THREADPOOL_FUNCTION(tppbsps$WRAPPER_TEXT$BORDER_CLIP$INVERSE_SELECTION$CYCLE_RANGE$SCORE_RANGE$WITH_REVERSE)
$if (CYCLE_RANGE == 1) [[

#ifdef PRF_CORE_REPEAT

]]
{
		char Header[1024]; 
		$if WITH_REVERSE [[
			unsigned char RevComp_Index_Mapping[ALPHABET_SIZE+2] __attribute__((aligned(16)));
		]]
		int res = SUCCESS;
// 	  printf("Thread started fct THREAD_FCT_NAME\n");
		
		/*************************************************************************/
    /*                          GET COMMON DATA                              */
    /*************************************************************************/
		common_t * const restrict common = _Data->common;
		
		/* For profile search we need to have */
		const struct Profile * const restrict prf = common->profile;
		const Compute_t * const restrict CoreCompute =common->Compute;
		
		/* For output we need */
		const OutputType_t * const restrict OutputType = common->OutputType;
		pthread_mutex_t * const restrict PrintLock = &(common->PrintLock);
		
		/*************************************************************************/
		/*                          ALLOCATE MEMORY                              */
		/*************************************************************************/
		assert(prf->Length > 0);
		const size_t prfLength = prf->Length;
		const size_t matrixLD  = prf->Length + 1;
		size_t LargestSequence = 2048UL;
		union lScores * restrict matrix = _mm_malloc(matrixLD*LargestSequence*sizeof(union lScores), 64);
		$if WITH_REVERSE [[
			union lScores * restrict rvmatrix = _mm_malloc(matrixLD*LargestSequence*sizeof(union lScores), 64);
		]]
		unsigned char * restrict SequenceIndex = malloc(LargestSequence*sizeof(unsigned char));
		int * restrict WORK = _mm_malloc(GetWorkArraySize(prf, CoreCompute), 64);
		if ( $if WITH_REVERSE [[ rvmatrix == NULL || ]] matrix == NULL || WORK == NULL || SequenceIndex == NULL ) {
			res = -1; 
			goto FIN;
		}
		$if (WRAPPER_TEXT == 1) [[ ]] $else [[
		_Bool * restrict HasAPath;
		/*if (!(OutputType->Specific.Text.OptimalOnly))*/ {
			HasAPath = (_Bool*) malloc(LargestSequence*sizeof(_Bool));
			if (HasAPath == NULL) {
				res = -1;
				goto FIN;
			}
		}
		]]
		$if ( (WRAPPER_TEXT == 0) | (WRAPPER_TEXT == 2) | (WRAPPER_TEXT == 3) | (WRAPPER_TEXT == 5) ) [[
			size_t OutputSequenceMemorySize = 0UL;
			unsigned char * restrict OutputSequence = NULL;
		]] $elif (WRAPPER_TEXT == 4) [[
			size_t AlignmentsMemorySize = 10;
			Alignment_t * Alignments = (Alignment_t*) malloc(AlignmentsMemorySize*sizeof(Alignment_t));
			if (Alignments == NULL) {
				fprintf(stderr, "Unable to increase alignments'size to %lu\n", AlignmentsMemorySize);
				pthread_exit((void*) 1);
			}
		]]
		$if (WRAPPER_TEXT == 4) [[ 
			unsigned char * restrict BackupSequence = malloc(LargestSequence*sizeof(unsigned char)); 
			if (BackupSequence == NULL) {
				res = -1;
				goto FIN;
			}
		]]
		
		/*************************************************************************/
		/*                          CONFIGURE WORKER                             */
		/*************************************************************************/
		$if WITH_REVERSE [[
			for (unsigned char a=0;a<ALPHABET_SIZE+2; a++) RevComp_Index_Mapping[a] = a;
			{
				unsigned char c;
				c = RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'A' - (int) 'A' ] ];
				RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'A' - (int) 'A' ] ] = RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'T' - (int) 'A' ] ];
				RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'T' - (int) 'A' ] ] = c;
			}
			{
				unsigned char c;
				c = RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'C' - (int) 'A' ] ];
				RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'C' - (int) 'A' ] ] = RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'G' - (int) 'A' ] ];
				RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'G' - (int) 'A' ] ] = c;
			}
		]]

    /* Assure all threads have been created before starting serving */
    threadpool_t* const restrict  thpool = _Data->thpool;
   
//		/* Register signal handler */
//     struct sigaction act;
//     act.sa_handler = thread_hold;
//     if (sigaction(SIGUSR1, &act, NULL) == -1) {
// 	    fprintf(stderr, "thread_do(): cannot handle SIGUSR1");
//     }
    
    /* Mark thread as alive (initialized) */
    pthread_mutex_lock(&thpool->thcount_lock);
    thpool->num_threads_alive += 1;
    pthread_mutex_unlock(&thpool->thcount_lock);
    
    // Initialize some other data
    pb_job_t * task = NULL;
		
    const int CutOff = prf->CutOff;
 		unsigned int AlignedSeqCounter = 0U;
		
		while(thpool->threads_keepalive) {
			bsem_wait(thpool->jobqueue_p.has_items);
			
			if (thpool->threads_keepalive){
			    pthread_mutex_lock(&thpool->thcount_lock);
			    thpool->num_threads_working++;
			    pthread_mutex_unlock(&thpool->thcount_lock);
			    
			    /* Read job from queue and execute it */
			    pthread_mutex_lock(&thpool->jobqueue_p.rwmutex);
			    task = (pb_job_t*) jobqueue_pull(&thpool->jobqueue_p);
			    pthread_mutex_unlock(&thpool->jobqueue_p.rwmutex);
			    
			    /***************************************************************/
			    /*                     START THE TASK                          */
			    /***************************************************************/
			    if (task) {
						const HoleData_t * const HReg = &(task->HReg);
						const unsigned int HoleNumber = HReg->HoleNumber;
				    const unsigned int nRegions   = HReg->nRegions;
// 						printf("Thread %lu working on hole %u, %u regions found\n", ((ThreadPool_Arg_t*)_Data)->ID, HoleNumber, nRegions);
						restrictReadstoHQ(HReg);
						
						for (int i=0; i<nRegions; i++) {
							if (HReg->Regions[i].type == Insert) {
								const int lSeqLength = (int) HReg->Regions[i].stop - (int) HReg->Regions[i].start;
								if (lSeqLength <= 1 || lSeqLength < prf->Length) continue;
								PFSequence PFSeq = { .ProfileIndex=SequenceIndex , .Length = (size_t) lSeqLength} ;
// 								printf("%.*s\n", (int) PFSeq.Length, &(task->Reads.Stream[HReg->Regions[i].start]));
// 								goto FIN;
								if (PFSeq.Length >= LargestSequence) {
									_mm_free(matrix);
									$if WITH_REVERSE [[_mm_free(rvmatrix);]]
									LargestSequence = (PFSeq.Length + 1UL + 2047UL) & ~(2047UL);
									matrix = _mm_malloc(matrixLD*LargestSequence*sizeof(union lScores), 64);
									$if WITH_REVERSE [[
										rvmatrix = _mm_malloc(matrixLD*LargestSequence*sizeof(union lScores), 64);
									]]
									SequenceIndex = (unsigned char*) realloc(SequenceIndex, LargestSequence*sizeof(unsigned char));
									if ( $if WITH_REVERSE [[rvmatrix == NULL ||]] matrix == NULL || SequenceIndex == NULL) {
										res = -2; 
										goto FIN;
									}
									PFSeq.ProfileIndex = SequenceIndex;
									$if (WRAPPER_TEXT == 1) [[ ]] $else [[
										/*if (!(OutputType->Specific.Text.OptimalOnly))*/ {
											HasAPath = realloc(HasAPath, LargestSequence*sizeof(_Bool));
											if (HasAPath == NULL) {
												res = -1;
												goto FIN;
											}
										}
										$if (WRAPPER_TEXT == 4) [[ 
											BackupSequence = realloc(BackupSequence, LargestSequence*sizeof(unsigned char)); 
											if (BackupSequence == NULL) {
												res = -1;
												goto FIN;
											}
										]]
									]]
								}
								unsigned char * const restrict SequenceText = &(task->Reads.Stream[HReg->Regions[i].start]);
								
								/* Copy sequence to local space index */ 
								memcpy(PFSeq.ProfileIndex, SequenceText, PFSeq.Length*sizeof(unsigned char));
								
								/* Translate into indices */
								TranslateSequenceToIndex(&PFSeq, prf->Alphabet_Mapping);
								
								/* Build matrix */
								CoreCompute->BuildMatrix(prf, PFSeq.ProfileIndex, matrix, WORK, NULL, 0, (size_t) PFSeq.Length);

								$if WITH_REVERSE [[
									/* Reverse indices */
									RevCompIndex(&PFSeq, RevComp_Index_Mapping);
									
									/* Build reverse matrix */
									CoreCompute->BuildMatrix(prf, PFSeq.ProfileIndex, rvmatrix, WORK, NULL, 0, PFSeq.Length);
								]]
								
								$if ( (WRAPPER_TEXT == 0) | (WRAPPER_TEXT == 2) | (WRAPPER_TEXT == 3)) [[ {
									Alignment_t Alignment;
									Alignment.Orientation = 1;
									unsigned int count = 1U;
									memset(HasAPath, 0, (1+PFSeq.Length)*sizeof(_Bool));
									do {
										/* Get Best Alignment */
										size_t OutputSequenceLength = CoreCompute->GetNextBestAlignment(matrix, HasAPath, &Alignment, PFSeq.Length, prfLength);
										if (OutputSequenceLength == 0UL) {
											if (Alignment.Score >= prf->CutOff) {
											fprintf(stderr, "Issue as alignment does not start with an ENTRY point! (score=%i, seqlength=%lu)\n%s\n",
															Alignment.Score, PFSeq.Length, SequenceText);
											}
											break;
										}
										
										/* Prevent further alignment to use this region */
										_Bool AlreadyUsed = false;
										assert(Alignment.Matrix.row.End <= PFSeq.Length);
										assert(Alignment.Matrix.row.Begin >= 0);
										for(int k=Alignment.Matrix.row.Begin; k<=Alignment.Matrix.row.End; ++k) {
											AlreadyUsed |= HasAPath[k]; 
											HasAPath[k] = true;
										}
											
										if (!AlreadyUsed) {
											_Bool KeepIt = true;
											$if SCORE_RANGE [[
												KeepIt &= (Alignment.Score >= OutputType->ScoreRange[0] && Alignment.Score <= OutputType->ScoreRange[1]);
											]]
											$if CYCLE_RANGE [[ 
												KeepIt &= (Alignment.Cycles >= OutputType->CycleRange[0] && Alignment.Cycles <= OutputType->CycleRange[1]);
											]]
											$if BORDER_CLIP [[
												KeepIt &= (Alignment.Region.sequence.Begin >= OutputType->BorderClip[0])
															&& ((Alignment.Region.sequence.End + OutputType->BorderClip[1]) <= PFSeq.Length);
											]]
											
											$if INVERSE_SELECTION [[
												KeepIt = !KeepIt;
											]]
											$if (BORDER_CLIP | SCORE_RANGE | CYCLE_RANGE | INVERSE_SELECTION) [[
												if (KeepIt)
											]] $else [[
												if ((Alignment.Score >= prf->CutOff || OutputType->Specific.Text.OptimalOnly) )
											]]
											{
												$if (WRAPPER_TEXT == 0) [[
													/* Get Aligned Sequence */
													if (OutputSequenceLength >= OutputSequenceMemorySize) {
														OutputSequenceMemorySize = OutputSequenceLength+1; 
														OutputSequence = (unsigned char*) realloc(OutputSequence, OutputSequenceMemorySize*sizeof(unsigned char));
														if (OutputSequence == NULL) {
															fputs("Unable to allocate memory\n", stderr);
															exit(1);
														}
													}
											
 													CoreCompute->GetAlignmentSequence(matrix, SequenceText, OutputSequence, &Alignment, OutputSequenceMemorySize, prfLength);
												]]
												$elif (WRAPPER_TEXT == 2) [[
													OutputSequence = SequenceText;
													OutputSequenceLength = Alignment.Region.sequence.Begin - 1;
												]]
												$elif (WRAPPER_TEXT == 3) [[
													OutputSequence = SequenceText + Alignment.Region.sequence.End + 1;
													OutputSequenceLength = PFSeq.Length - Alignment.Region.sequence.End;
												]]
												
												snprintf(Header, 1024,"ZMW_%u_%i/%u-%u/%u", HoleNumber, i, HReg->Regions[i].start, HReg->Regions[i].stop, count++);
												pthread_mutex_lock(PrintLock);
												OutputType->Specific.Text.Print(prf,
																												OutputSequence,
																												&Alignment, Header, OutputSequenceLength, 0.0f);
												pthread_mutex_unlock(PrintLock);
												$if (BORDER_CLIP | SCORE_RANGE | CYCLE_RANGE | INVERSE_SELECTION) [[
													if (OutputType->Specific.Text.OptimalOnly) break;
												]]
											}
										}
										$if (BORDER_CLIP | SCORE_RANGE | CYCLE_RANGE) [[ ]] $else [[
											if (OutputType->Specific.Text.OptimalOnly) break;
										]]
									} while ($if SCORE_RANGE [[ Alignment.Score >= OutputType->ScoreRange[0] ]] $else [[ Alignment.Score >= prf->CutOff ]] );
									
									$if WITH_REVERSE [[
										memset(HasAPath, 0, (1+PFSeq.Length)*sizeof(_Bool));
										PerformRevComp(SequenceText, PFSeq.Length);
										Alignment.Orientation = -1;
										do {
											/* Get Best Alignment */
											size_t OutputSequenceLength = CoreCompute->GetNextBestAlignment(rvmatrix, HasAPath, &Alignment, PFSeq.Length, prfLength);
											if (OutputSequenceLength == 0) {
												if (Alignment.Score >= prf->CutOff) {
													fprintf(stderr, "Issue as alignment does not start with an ENTRY point! (score=%i, seqlength=%lu)\n%s\n",
																Alignment.Score, PFSeq.Length, SequenceText);
												}
												break;
											}
											
											/* Prevent further alignment to use this region */
											_Bool AlreadyUsed = false;
											assert(Alignment.Matrix.row.End <= PFSeq.Length);
											assert(Alignment.Matrix.row.Begin >=0);
											for(int k=Alignment.Matrix.row.Begin; k<=Alignment.Matrix.row.End; ++k) {
												AlreadyUsed |= HasAPath[k]; 
												HasAPath[k] = true;
											}
												
											if (!AlreadyUsed) {
												_Bool KeepIt = true;
												$if SCORE_RANGE [[
													KeepIt &= (Alignment.Score >= OutputType->ScoreRange[0] && Alignment.Score <= OutputType->ScoreRange[1]);
												]]
												$if CYCLE_RANGE [[ 
													KeepIt &= (Alignment.Cycles >= OutputType->CycleRange[0] && Alignment.Cycles <= OutputType->CycleRange[1]);
												]]
												$if BORDER_CLIP [[
													KeepIt &= Alignment.Region.sequence.Begin >= OutputType->BorderClip[0]
																&& ((Alignment.Region.sequence.End + OutputType->BorderClip[1]) <= PFSeq.Length);
												]]
												
												$if INVERSE_SELECTION [[
													KeepIt = !KeepIt;
												]]
												$if (BORDER_CLIP | SCORE_RANGE | CYCLE_RANGE | INVERSE_SELECTION) [[
													if (KeepIt)
												]] $else [[
													if ((Alignment.Score >= prf->CutOff || OutputType->Specific.Text.OptimalOnly) )
												]]
												{
													$if (WRAPPER_TEXT == 0) [[
														/* Get Aligned Sequence */
														if (OutputSequenceLength >= OutputSequenceMemorySize) {
															OutputSequenceMemorySize = OutputSequenceLength+1; 
															OutputSequence = (unsigned char*) realloc(OutputSequence, OutputSequenceMemorySize*sizeof(unsigned char));
															if (OutputSequence == NULL) {
																fputs("Unable to allocate memory\n", stderr);
																exit(1);
															}
														}
												
														CoreCompute->GetAlignmentSequence(rvmatrix, SequenceText, OutputSequence, &Alignment, OutputSequenceMemorySize, prfLength);
													]]
													$elif (WRAPPER_TEXT == 2) [[
														OutputSequence = SequenceText;
														OutputSequenceLength = Alignment.Region.sequence.Begin - 1;
													]]
													$elif (WRAPPER_TEXT == 3) [[
														OutputSequence = SequenceText + Alignment.Region.sequence.End + 1;
														OutputSequenceLength = PFSeq.Length - Alignment.Region.sequence.End;
													]]
													
													snprintf(Header, 1024,"ZMW_%u_%i/%u-%u/%u", HoleNumber, i, HReg->Regions[i].start, HReg->Regions[i].stop, count++);
													pthread_mutex_lock(PrintLock);
													OutputType->Specific.Text.Print(prf, OutputSequence, &Alignment, Header, OutputSequenceLength, 0.0f);
													pthread_mutex_unlock(PrintLock);
													$if (BORDER_CLIP | SCORE_RANGE | CYCLE_RANGE | INVERSE_SELECTION) [[
														if (OutputType->Specific.Text.OptimalOnly) break;
													]]
												}
											}
											$if (BORDER_CLIP | SCORE_RANGE | CYCLE_RANGE) [[ ]] $else [[
												if (OutputType->Specific.Text.OptimalOnly) break;
											]]
										}  while ($if SCORE_RANGE [[ Alignment.Score >= OutputType->ScoreRange[0] ]] $else [[ Alignment.Score >= prf->CutOff ]] );
									]]
								} ]]
								$elif (WRAPPER_TEXT == 4) [[ {									///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
									// IN_BETWEEN OUTPUT
									unsigned int count = 0U;
									memset(HasAPath, 0, (1+PFSeq.Length));
									Alignment_t * restrict Alignment;
									do {
										Alignment = &Alignments[count];
										Alignment->Orientation = 0;
										/* Get Best Alignment */
										size_t OutputSequenceLength = CoreCompute->GetNextBestAlignment(matrix, HasAPath, Alignment, PFSeq.Length, prfLength);
										if (OutputSequenceLength == 0) {
											if (Alignment->Score >= prf->CutOff) {
												fprintf(stderr, "Issue as alignment does not start with an ENTRY point! (score=%i, seqlength=%lu)\n%s\n",
															Alignment->Score, PFSeq.Length, SequenceText);
											}
											break;
										}
										
										/* Prevent further alignment to use this region */
										_Bool AlreadyUsed = false;
										assert(Alignment->Matrix.row.End <= PFSeq.Length);
										assert(Alignment->Matrix.row.Begin >=0);
										assert(Alignment->Region.sequence.Begin >= 0);
										assert(Alignment->Region.sequence.End <= PFSeq.Length);
										for(int k=Alignment->Matrix.row.Begin; k<=Alignment->Matrix.row.End; ++k) {
											AlreadyUsed |= HasAPath[k]; 
											HasAPath[k] = true;
										}
											
										if (!AlreadyUsed) {
											_Bool KeepIt = true;
											$if SCORE_RANGE [[
												KeepIt &= (Alignment->Score >= OutputType->ScoreRange[0] && Alignment->Score <= OutputType->ScoreRange[1]);
											]]
											$if CYCLE_RANGE [[ 
												KeepIt &= (Alignment->Cycles >= OutputType->CycleRange[0] && Alignment->Cycles <= OutputType->CycleRange[1]);
											]]
											$if BORDER_CLIP [[
												KeepIt &= Alignment->Region.sequence.Begin >= OutputType->BorderClip[0]
															&& ((Alignment->Region.sequence.End + OutputType->BorderClip[1]) <= PFSeq.Length);
											]]
											
											$if INVERSE_SELECTION [[
												KeepIt = !KeepIt;
											]]
											$if (BORDER_CLIP | SCORE_RANGE | CYCLE_RANGE | INVERSE_SELECTION) [[
												if (KeepIt)
											]] $else [[
												if ((Alignment->Score >= prf->CutOff || OutputType->Specific.Text.OptimalOnly) )
											]]
											{
												if (++count >= AlignmentsMemorySize) {
													AlignmentsMemorySize += 10;
													Alignments = (Alignment_t*) realloc(Alignments, AlignmentsMemorySize*sizeof(Alignment_t));
													if (Alignments == NULL) {
														fprintf(stderr, "Unable to increase alignments'size to %lu\n", AlignmentsMemorySize);
														pthread_exit((void*) 1);
													}
													Alignment = &Alignments[count-1];
												}
											}
										}
									}  while ($if SCORE_RANGE [[ OutputType->ScoreRange[0] ]] $else [[ Alignment->Score >= prf->CutOff ]] );
									
									$if WITH_REVERSE [[
										memset(HasAPath, 0, (1+PFSeq.Length));
										memcpy(BackupSequence, SequenceText, PFSeq.Length);
										PerformRevComp(BackupSequence, PFSeq.Length);
										do {
											Alignment = &Alignments[count];
											Alignment->Orientation = -1;
											/* Get Best Alignment */
											size_t OutputSequenceLength = CoreCompute->GetNextBestAlignment(rvmatrix, HasAPath, Alignment, PFSeq.Length, prfLength);
											if (OutputSequenceLength == 0) {
												if (Alignment->Score >= prf->CutOff) {
													fprintf(stderr, "Issue as alignment does not start with an ENTRY point! (score=%i, seqlength=%lu)\n%s\n",
																Alignment->Score, PFSeq.Length, SequenceText);
												}
												break;
											}
											
											/* Prevent further alignment to use this region */
											_Bool AlreadyUsed = false;
											assert(Alignment->Matrix.row.End <= PFSeq.Length);
											assert(Alignment->Matrix.row.Begin >=0);
											for(int k=Alignment->Matrix.row.Begin; k<=Alignment->Matrix.row.End; ++k) {
												AlreadyUsed |= HasAPath[k]; 
												HasAPath[k] = true;
											}
												
											if (!AlreadyUsed) {
												_Bool KeepIt = true;
												$if SCORE_RANGE [[
													KeepIt &= (Alignment->Score >= OutputType->ScoreRange[0] && Alignment->Score <= OutputType->ScoreRange[1]);
												]]
												$if CYCLE_RANGE [[ 
													KeepIt &= (Alignment->Cycles >= OutputType->CycleRange[0] && Alignment->Cycles <= OutputType->CycleRange[1]);
												]]
												$if BORDER_CLIP [[
													KeepIt &= Alignment->Region.sequence.Begin >= OutputType->BorderClip[0]
																&& ((Alignment->Region.sequence.End + OutputType->BorderClip[1]) <= PFSeq.Length);
												]]
												
												$if INVERSE_SELECTION [[
													KeepIt = !KeepIt;
												]]
												$if (BORDER_CLIP | SCORE_RANGE | CYCLE_RANGE | INVERSE_SELECTION) [[
													if (KeepIt)
												]] $else [[
													if ((Alignment->Score >= prf->CutOff || OutputType->Specific.Text.OptimalOnly) )
												]]
												{
													if (++count >= AlignmentsMemorySize) {
														AlignmentsMemorySize += 10;
														Alignments = (Alignment_t*) realloc(Alignments, AlignmentsMemorySize*sizeof(Alignment_t));
														if (Alignments == NULL) {
															fprintf(stderr, "Unable to increase alignments'size to %lu\n", AlignmentsMemorySize);
															pthread_exit((void*) 1);
														}
														Alignment = &Alignments[count-1];
													}
												}
											}
										}  while ($if SCORE_RANGE [[ Alignment->Score >= OutputType->ScoreRange[0] ]] $else [[ Alignment->Score >= prf->CutOff ]] );
									]]
									
									/* Sort the Alignments */
									if (count) {
										qsort(Alignments, (size_t) count, sizeof(Alignment_t), compareAlignments);
										{
											const int ThisSeqLength = Alignments[0].Region.sequence.Begin;
											if (ThisSeqLength > 0) {
												const unsigned char Backup = SequenceText[ThisSeqLength];
												SequenceText[ThisSeqLength] = '\0';
												const unsigned char * const AlignedSequence = SequenceText;// - 1;
												snprintf(Header, 1024, "ZMW_%u_%i/%u-%u/0 before %s with score %i", HoleNumber, i, HReg->Regions[i].start,
																Alignments[0].Region.sequence.Begin, prf->Identification, Alignments[0].Score);
												pthread_mutex_lock(PrintLock);
												OutputType->Specific.Text.Print(prf, AlignedSequence, &Alignments[0], Header, (size_t) ThisSeqLength, 0.0f);
												pthread_mutex_unlock(PrintLock);
												SequenceText[ThisSeqLength] = Backup;
											}
										}
										if (count >= 2) {
											for (unsigned int k=1; k<count; k++) { 
												const ssize_t ThisSeqLength = (ssize_t) Alignments[k].Region.sequence.Begin - (ssize_t) Alignments[k-1].Region.sequence.End - 1;
												if (ThisSeqLength > 0) {
													const unsigned char Backup = SequenceText[Alignments[k].Region.sequence.Begin];
													SequenceText[Alignments[k].Region.sequence.Begin] = '\0';
													const unsigned char * const AlignedSequence = SequenceText + Alignments[k-1].Region.sequence.End + 1;
													snprintf(Header, 1024, "ZMW_%u_%i/%u-%u/%u in between %s with score %i and %i", HoleNumber, i,
																	Alignments[k-1].Region.sequence.End + 1, Alignments[k].Region.sequence.Begin - 1, count,
																	prf->Identification, Alignments[k-1].Score, Alignments[k].Score);
													pthread_mutex_lock(PrintLock);
													OutputType->Specific.Text.Print(prf, AlignedSequence, &Alignments[k], Header, (size_t) ThisSeqLength, 0.0f);
													pthread_mutex_unlock(PrintLock);
													SequenceText[Alignments[k].Region.sequence.Begin] = Backup;
												}
											}
										}
										{
											const ssize_t ThisSeqLength = (ssize_t) PFSeq.Length - (ssize_t) Alignments[count-1].Region.sequence.End - 1;
											if (ThisSeqLength > 0L) {
												const unsigned char * const AlignedSequence = SequenceText + Alignments[count-1].Region.sequence.End + 1;
												snprintf(Header, 1024, "ZMW_%u_%i/%u-%u/%u after %s with score %i", HoleNumber, i, Alignments[count-1].Region.sequence.End + 1,
																HReg->Regions[count-1].stop, count-1, prf->Identification, Alignments[count-1].Score);
												pthread_mutex_lock(PrintLock);
												OutputType->Specific.Text.Print(prf, AlignedSequence, &Alignments[count-1], Header, (size_t) ThisSeqLength, 0.0f);
												pthread_mutex_unlock(PrintLock);
											}
										}
									}
								} ]]
								$elif (WRAPPER_TEXT == 1) [[ {
									// SOURCE OUTPUT
									Alignment_t Alignment;
									Alignment.Orientation = 1;
									const Alignment_t * restrict AlignPtr = &Alignment;
									/* Get Best Alignment */
									const size_t OutputSequenceLength = CoreCompute->GetBestAlignment(matrix, &Alignment, PFSeq.Length, prfLength);
									
									$if WITH_REVERSE [[
										Alignment_t rvAlignment;
										rvAlignment.Orientation = -1;
										/* Get Best Alignment */
										const size_t rvOutputSequenceLength = CoreCompute->GetBestAlignment(rvmatrix, &rvAlignment, PFSeq.Length, prfLength);
										if (rvOutputSequenceLength == 0) {
											if (rvAlignment.Score >= prf->CutOff) {
												fprintf(stderr, "Issue as alignment does not start with an ENTRY point! (score=%i, seqlength=%lu)\n%.*s\n",
															rvAlignment.Score, PFSeq.Length, (int)PFSeq.Length, SequenceText);
											}
										}
										else {
											if (rvAlignment.Score > Alignment.Score) {
												AlignPtr =	&rvAlignment;
												PerformRevComp(SequenceText, PFSeq.Length);
											}
										}
									]]
									$else [[
										if (OutputSequenceLength == 0) {
											if (Alignment.Score >= prf->CutOff) {
												fprintf(stderr, "Issue as alignment does not start with an ENTRY point! (score=%i, seqlength=%lu)\n%.*s\n",
															Alignment.Score, PFSeq.Length, (int)PFSeq.Length, SequenceText);
											}
											continue;
										}
									]]
									
									_Bool KeepIt = true;
									$if SCORE_RANGE [[
										KeepIt &= (Alignment.Score >= OutputType->ScoreRange[0] && Alignment.Score <= OutputType->ScoreRange[1]);
									]]
									$if CYCLE_RANGE [[ 
										KeepIt &= (Alignment.Cycles >= OutputType->CycleRange[0] && Alignment.Cycles <= OutputType->CycleRange[1]);
									]]
									$if BORDER_CLIP [[
										KeepIt &= Alignment.Region.sequence.Begin >= OutputType->BorderClip[0]
														&& ((Alignment.Region.sequence.End + OutputType->BorderClip[1]) <= PFSeq.Length);
									]]
									
									$if INVERSE_SELECTION [[
										KeepIt = !KeepIt;
									]]
									$if (BORDER_CLIP | SCORE_RANGE | CYCLE_RANGE | INVERSE_SELECTION) [[
										if (KeepIt)
									]] $else [[
										if (Alignment.Score >= prf->CutOff)
									]]	
									{
										snprintf(Header, 1024,"ZMW_%u_%i/%u-%u", HoleNumber, i, HReg->Regions[i].start, HReg->Regions[i].stop);
										pthread_mutex_lock(PrintLock);
										OutputType->Specific.Text.Print(prf, SequenceText, AlignPtr, Header, PFSeq.Length, 0.0f );
										pthread_mutex_unlock(PrintLock);
									}
								} ]]
								$elif (WRAPPER_TEXT == 5) [[ {
									///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
									// SOURCE OUTPUT
									Alignment_t Alignment;
									Alignment.Orientation = 1;
									const Alignment_t * restrict AlignPtr = &Alignment;
									const union lScores * restrict matrixPtr = matrix;
									/* Get Best Alignment */
									size_t OutputSequenceLength = CoreCompute->GetBestAlignment(matrix, &Alignment, PFSeq.Length, prfLength);
									
									if (OutputSequenceLength == 0  && Alignment.Score >= prf->CutOff) {
										fprintf(stderr, "Issue as alignment does not start with an ENTRY point! (score=%i, seqlength=%lu)\n%s\n",
														Alignment.Score, PFSeq.Length,  SequenceText);
									}
									Alignment_t rvAlignment;
									rvAlignment.Orientation = -1;
									/* Get Best Alignment */
									const size_t rvOutputSequenceLength = CoreCompute->GetBestAlignment(rvmatrix, &rvAlignment, PFSeq.Length, prfLength);
									if (rvOutputSequenceLength == 0  && rvAlignment.Score >= prf->CutOff) {
										fprintf(stderr, "Issue as alignment does not start with an ENTRY point! (score=%i, seqlength=%lu)\n%s\n",
														rvAlignment.Score, PFSeq.Length, SequenceText);
									}
									else {
										if (rvAlignment.Score > Alignment.Score) {
											AlignPtr = &rvAlignment;
											OutputSequenceLength = rvOutputSequenceLength;
											matrixPtr = rvmatrix;
										}
									}
									
									if (OutputSequenceLength > 0) {
										_Bool KeepIt = true;
										$if SCORE_RANGE [[
											KeepIt &= (Alignment.Score >= OutputType->ScoreRange[0] && Alignment.Score <= OutputType->ScoreRange[1]);
										]]
										$if CYCLE_RANGE [[ 
											KeepIt &= (Alignment.Cycles >= OutputType->CycleRange[0] && Alignment.Cycles <= OutputType->CycleRange[1]);
										]]
										$if BORDER_CLIP [[
											KeepIt &= Alignment.Region.sequence.Begin >= OutputType->BorderClip[0]
															&& ((Alignment.Region.sequence.End + OutputType->BorderClip[1]) <= PFSeq.Length);
										]]
										
										$if INVERSE_SELECTION [[
											KeepIt = !KeepIt;
										]]
										
										if (KeepIt) {
											if (AlignPtr->Orientation < 0) {
												PerformRevComp(SequenceText, PFSeq.Length);
											}
											/* Get Aligned Sequence */
											if (OutputSequenceLength > OutputSequenceMemorySize) {
												OutputSequenceMemorySize = OutputSequenceLength; 
												OutputSequence = (unsigned char*) realloc(OutputSequence, OutputSequenceMemorySize*sizeof(unsigned char));
												if (OutputSequence == NULL) {
													fputs("Unable to allocate memory\n", stderr);
													exit(1);
												}
											}
											
											CoreCompute->GetAlignmentSequence(matrixPtr, SequenceText, OutputSequence, AlignPtr, OutputSequenceMemorySize, prfLength);
											snprintf(Header, 1024,"ZMW_%u_%i/%u-%u", HoleNumber, i, HReg->Regions[i].start, HReg->Regions[i].stop);
											pthread_mutex_lock(PrintLock);
											OutputType->Specific.Text.Print(prf, OutputSequence, AlignPtr, Header, OutputSequenceLength, 0.0f );
											pthread_mutex_unlock(PrintLock);
										}
									}
								} ]]
							}
						}
						
						/* Return the job memory slot */
						pthread_mutex_lock(&thpool->donequeue_p.rwmutex);
						jobqueue_push(&thpool->donequeue_p, (job_t*) task);
						pthread_mutex_unlock(&thpool->donequeue_p.rwmutex);
					}
			    pthread_mutex_lock(&thpool->thcount_lock);
			    thpool->num_threads_working--;
			    pthread_mutex_unlock(&thpool->thcount_lock);
			}
    }
    
    /////////////////////////////////////////////////////////////////////////////////////////////////////////
		//SUMMARIZE;
		common->Counters[_Data->threadID] = AlignedSeqCounter;
     
    FIN:
    pthread_mutex_lock(&thpool->thcount_lock);
    thpool->num_threads_alive--;
    pthread_mutex_unlock(&thpool->thcount_lock);
		    
		if (WORK) _mm_free(WORK);
		if (matrix) _mm_free(matrix);
		$if WITH_REVERSE [[if (rvmatrix) _mm_free(rvmatrix);]]
		if (SequenceIndex) free(SequenceIndex);
		$if (WRAPPER_TEXT == 1) [[ ]] $else [[ free(HasAPath); ]]
		$if ((WRAPPER_TEXT == 0)|(WRAPPER_TEXT == 5)) [[ free(OutputSequence); ]]
		$if (WRAPPER_TEXT == 4) [[ free(BackupSequence); ]]
		
    if( res != SUCCESS) {
      fprintf(stderr, "Thread %u error code %i\n", _Data->threadID, res);
      if (task) {
				pthread_mutex_lock(&thpool->thcount_lock);
				thpool->num_threads_working--;
				pthread_mutex_unlock(&thpool->thcount_lock);
      }
      thpool->threads_keepalive = 0;
    }
    
    _Data->returnState = (void*) (uintptr_t) res;
		
    return 0;
}
$if (CYCLE_RANGE == 1) [[

#else
{
		fputs("Enable PRF_CORE_REPEAT for cycles!\n", stderr);
		return (void*) 1;
}
#endif

]]
]]
]] ]] ]] ]] ]]
]]


/****************************************************************************************************
 * MATRIX PROFILES: HISTOGRAM
 */
$for HISTO_CYCLE [[
$for CYCLE_RANGE [[ $for SCORE_RANGE [[ $for BORDER_CLIP [[ $for WITH_REVERSE [[
$if (SCORE_RANGE | (HISTO_CYCLE & CYCLE_RANGE)) [[

static
THREADPOOL_FUNCTION(tppbsph$HISTO_CYCLE$BORDER_CLIP$CYCLE_RANGE$SCORE_RANGE$WITH_REVERSE)
$if (CYCLE_RANGE == 1) [[

#ifdef PRF_CORE_REPEAT

]]
{
		char Header[1024]; 
		$if WITH_REVERSE [[
			unsigned char RevComp_Index_Mapping[ALPHABET_SIZE+2] __attribute__((aligned(16)));
		]]
		int res = SUCCESS;
// 	  printf("Thread started fct THREAD_FCT_NAME\n");
		
		/*************************************************************************/
    /*                          GET COMMON DATA                              */
    /*************************************************************************/
		common_t * const common = _Data->common;
		
		/* For profile search we need to have */
		const struct Profile * const restrict prf = common->profile;
		const Compute_t * const restrict CoreCompute =common->Compute;
		
		/* For output we need */
		$if HISTO_CYCLE [[
			const unsigned short int range[2] = { (common->OutputType)->CycleRange[0], 
																						(common->OutputType)->CycleRange[1] }; 
			$if SCORE_RANGE [[
				const int ScoreRange[2] = { (common->OutputType)->ScoreRange[0],
																		(common->OutputType)->ScoreRange[1] };
			]]
		]] $else [[
			const int range[2] = { (common->OutputType)->ScoreRange[0],
														 (common->OutputType)->ScoreRange[1] };
			$if CYCLE_RANGE [[
					const unsigned int CycleRange[2] = { (common->OutputType)->CycleRange[0], 
																							 (common->OutputType)->CycleRange[1] };
			]]
		]]
		
		$if BORDER_CLIP [[
			unsigned short int  BorderClip[2] =  { (common->OutputType)->BorderClip[0],
																						 (common->OutputType)->BorderClip[1] };
		
		]]
		const size_t HistogramBins = range[1] - range[0] + 1;
		size_t * const restrict Histogram = common->Histograms + HistogramBins*(_Data->threadID);
		
		/*************************************************************************/
		/*                          ALLOCATE MEMORY                              */
		/*************************************************************************/
		const size_t prfLength = prf->Length;
		const size_t matrixLD  = prf->Length + 1;
		size_t LargestSequence = 2048;
		union lScores * restrict matrix = _mm_malloc(matrixLD*LargestSequence*sizeof(union lScores), 64);
		$if WITH_REVERSE [[
			union lScores * restrict rvmatrix = _mm_malloc(matrixLD*LargestSequence*sizeof(union lScores), 64);
		]]
		unsigned char * restrict SequenceIndex = malloc(LargestSequence*sizeof(unsigned char));
		int * restrict WORK           = _mm_malloc(GetWorkArraySize(prf, CoreCompute),64);
		if ( $if WITH_REVERSE [[ rvmatrix == NULL || ]] matrix == NULL || WORK == NULL || SequenceIndex == NULL ) {
			res = -1; 
			goto FIN;
		}
				
		/*************************************************************************/
		/*                          CONFIGURE WORKER                             */
		/*************************************************************************/
		$if WITH_REVERSE [[
			for (unsigned char a=0;a<ALPHABET_SIZE+2; a++) RevComp_Index_Mapping[a] = a;
			{
				unsigned char c;
				c = RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'A' - (int) 'A' ] ];
				RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'A' - (int) 'A' ] ] = RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'T' - (int) 'A' ] ];
				RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'T' - (int) 'A' ] ] = c;
			}
			{
				unsigned char c;
				c = RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'C' - (int) 'A' ] ];
				RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'C' - (int) 'A' ] ] = RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'G' - (int) 'A' ] ];
				RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'G' - (int) 'A' ] ] = c;
			}
		]]

    /* Assure all threads have been created before starting serving */
    threadpool_t* const restrict  thpool = _Data->thpool;
   
//		/* Register signal handler */
//     struct sigaction act;
//     act.sa_handler = thread_hold;
//     if (sigaction(SIGUSR1, &act, NULL) == -1) {
// 	    fprintf(stderr, "thread_do(): cannot handle SIGUSR1");
//     }
    
    /* Mark thread as alive (initialized) */
    pthread_mutex_lock(&thpool->thcount_lock);
    thpool->num_threads_alive += 1;
    pthread_mutex_unlock(&thpool->thcount_lock);
    
    // Initialize some other data
    pb_job_t * task = NULL;
    size_t Missed = 0UL;
		
		while(thpool->threads_keepalive) {
			bsem_wait(thpool->jobqueue_p.has_items);
			
			if (thpool->threads_keepalive){
			    pthread_mutex_lock(&thpool->thcount_lock);
			    thpool->num_threads_working++;
			    pthread_mutex_unlock(&thpool->thcount_lock);
			    
			    /* Read job from queue and execute it */
			    pthread_mutex_lock(&thpool->jobqueue_p.rwmutex);
			    task = (pb_job_t*) jobqueue_pull(&thpool->jobqueue_p);
			    pthread_mutex_unlock(&thpool->jobqueue_p.rwmutex);
			    
			    /***************************************************************/
			    /*                     START THE TASK                          */
			    /***************************************************************/
			    if (task) {
						const HoleData_t * const HReg = &(task->HReg);
						const unsigned int HoleNumber = HReg->HoleNumber;
				    const unsigned int nRegions   = HReg->nRegions;
						restrictReadstoHQ(HReg);
						
						for (int i=0; i<nRegions; i++) {
							if (HReg->Regions[i].type == Insert) {
								const int lSeqLength = (int) HReg->Regions[i].stop - (int) HReg->Regions[i].start;
								if (lSeqLength <= 1) continue;
								PFSequence PFSeq = { .ProfileIndex=SequenceIndex , .Length = lSeqLength} ;

								if (PFSeq.Length >= LargestSequence) {
									_mm_free(matrix);
									$if WITH_REVERSE [[_mm_free(rvmatrix);]]
									LargestSequence = (PFSeq.Length + 1UL + 2047UL) & ~(2047UL);
									matrix        = _mm_malloc(matrixLD*LargestSequence*sizeof(union lScores), 64);
									$if WITH_REVERSE [[
										rvmatrix      = _mm_malloc(matrixLD*LargestSequence*sizeof(union lScores), 64);
									]]
									SequenceIndex = (unsigned char*) realloc(SequenceIndex, LargestSequence*sizeof(unsigned char));
									if ( $if WITH_REVERSE [[rvmatrix == NULL ||]] matrix == NULL || SequenceIndex == NULL) {
										res = -2; 
										goto FIN;
									}
									PFSeq.ProfileIndex = SequenceIndex;
								}
								const unsigned char * const restrict SequenceText = &(task->Reads.Stream[HReg->Regions[i].start]);
								
								/* Copy sequence to local space index */ 
								memcpy(PFSeq.ProfileIndex, SequenceText, PFSeq.Length);
								
								/* Translate into indices */
								TranslateSequenceToIndex(&PFSeq, prf->Alphabet_Mapping);
								
								/* Build matrix */
								CoreCompute->BuildMatrix(prf, PFSeq.ProfileIndex, matrix, WORK, NULL, 0, PFSeq.Length);
								
								$if WITH_REVERSE [[
									/* Reverse indices */
									RevCompIndex(&PFSeq, RevComp_Index_Mapping);
									
									/* Build reverse matrix */
									CoreCompute->BuildMatrix(prf, PFSeq.ProfileIndex, rvmatrix, WORK, NULL, 0, PFSeq.Length);
								]]
								
								/////////////////////////////////////////////////////////////////////////////////////////////////////////
								// WORK_ON_MATRICES;
								$if CYCLE_RANGE [[ {
									ScoreCycle_t SC $if WITH_REVERSE [[ , rvSC ]] ;
									GetBestScoreAndCycles(matrix, PFSeq.Length, prfLength, &SC);

									$if WITH_REVERSE [[ GetBestScoreAndCycles(rvmatrix, PFSeq.Length, prfLength, &rvSC); ]]
									$if BORDER_CLIP [[
										if ((SC.Begin <= BorderClip[0]) || (SC.End+BorderClip[1] >= PFSeq.Length)) {
											$if SCORE_RANGE [[ SC.Score = NLOW; ]]
											$if CYCLE_RANGE [[ SC.Cycles = 0; ]]
										}
									]]
									$if (HISTO_CYCLE & SCORE_RANGE) [[
										if (SC.Score < ScoreRange[0] || SC.Score > ScoreRange[1]) {
											SC.Cycles = 0;
										}
										$if WITH_REVERSE [[
											if (rvSC.Score < ScoreRange[0] || rvSC.Score > ScoreRange[1]) {
												rvSC.Cycles = 0;
											}
										]]
									]]
									$if (CYCLE_RANGE & ~(HISTO_CYCLE)) [[
										if (SC.Cycles < CycleRange[0] || SC.Cycles > CycleRange[1]) {
											SC.Score = NLOW;
										}
										$if WITH_REVERSE [[
											if (rvSC.Cycles < CycleRange[0] || rvSC.Cycles > CycleRange[1]) {
												rvSC.Score = NLOW;
											}
										]]
									]]
									
									$if WITH_REVERSE [[
										$if BORDER_CLIP [[
											if ((rvSC.Begin <= BorderClip[0]) || (rvSC.End+BorderClip[1] >= PFSeq.Length)) {
												$if SCORE_RANGE [[ rvSC.Score = NLOW; ]]
												$if CYCLE_RANGE [[ rvSC.Cycles = 0; ]]
											}
										]]
										$if HISTO_CYCLE [[
											if (rvSC.Cycles > SC.Cycles) SC.Cycles = rvSC.Cycles;
										]] $else [[
											if (rvSC.Score > SC.Score) SC.Score = rvSC.Score;
										]]
									]]
									
									$if HISTO_CYCLE [[
										if (SC.Cycles >= range[0] && SC.Cycles <= range[1]) {
											Histogram[SC.Cycles-range[0] ]++;
										}
										else 
											Missed++;
									]]
									$else [[
										if (SC.Score >= range[0] && SC.Score <= range[1]) {
											Histogram[SC.Score-range[0] ]++;
										}
										else 
											Missed++;
									]]
								} ]]
								$else [[ {
									$if BORDER_CLIP [[
										Alignment_t Alignment;
										CoreCompute->GetBestAlignment(matrix, &Alignment, PFSeq.Length, prfLength);
										if ( (Alignment.Region.sequence.Begin <= BorderClip[0]) 
											|| (Alignment.Region.sequence.End+BorderClip[1] >= PFSeq.Length)) {
											Alignment.Score = NLOW;
										}
										$if WITH_REVERSE [[
											Alignment_t rvAlignment;
											CoreCompute->GetBestAlignment(rvmatrix, &rvAlignment, PFSeq.Length, prfLength);
											if ( (rvAlignment.Region.sequence.Begin <= BorderClip[0]) 
											  || (rvAlignment.Region.sequence.End+BorderClip[1] >= PFSeq.Length)) {
												rvAlignment.Score = NLOW;
											}
											else {
												if (rvAlignment.Score > Alignment.Score) Alignment.Score = rvAlignment.Score;
											}
										]]
										if (Alignment.Score >= range[0] && Alignment.Score <= range[1])
											Histogram[Alignment.Score-range[0] ]++;
										else
											Missed++;
									]]
									$else [[
										int Score = CoreCompute->GetBestScore(matrix, PFSeq.Length, prfLength);
										$if WITH_REVERSE [[
											const int rvScore = CoreCompute->GetBestScore(rvmatrix, PFSeq.Length, prfLength);
											if (rvScore > Score) Score = rvScore;
										]]
										if (Score >= range[0] && Score <= range[1]) {
											Histogram[Score-range[0] ]++;
										}
										else 
											Missed++;
										]]
								} ]]
							}
						}
						
						/* Return the job memory slot */
						pthread_mutex_lock(&thpool->donequeue_p.rwmutex);
						jobqueue_push(&thpool->donequeue_p, (job_t*) task);
						pthread_mutex_unlock(&thpool->donequeue_p.rwmutex);
					}
			    pthread_mutex_lock(&thpool->thcount_lock);
			    thpool->num_threads_working--;
			    pthread_mutex_unlock(&thpool->thcount_lock);
			}
    }
    
    /////////////////////////////////////////////////////////////////////////////////////////////////////////
		//SUMMARIZE;
		common->Counters[_Data->threadID] = Missed;
     
    FIN:
    pthread_mutex_lock(&thpool->thcount_lock);
    thpool->num_threads_alive--;
    pthread_mutex_unlock(&thpool->thcount_lock);
		    
		if (WORK) _mm_free(WORK);
		if (matrix) _mm_free(matrix);
		$if WITH_REVERSE [[if (rvmatrix) _mm_free(rvmatrix);]]
		if (SequenceIndex) free(SequenceIndex);
	
    if( res != SUCCESS) {
      fprintf(stderr, "Thread %u error code %i\n", _Data->threadID, res);
      if (task) {
				pthread_mutex_lock(&thpool->thcount_lock);
				thpool->num_threads_working--;
				pthread_mutex_unlock(&thpool->thcount_lock);
      }
      thpool->threads_keepalive = 0;
    }
    
    _Data->returnState = (void*) (uintptr_t) res;
		
    return 0;
}
$if (CYCLE_RANGE == 1) [[

#else
{
		fputs("Enable PRF_CORE_REPEAT for cycles!\n", stderr);
		return (void*) 1;
}
#endif

]]

]]
]] ]] ]] ]]
]]


/****************************************************************************************************
 * MATRIX PROFILES: DENSITY
 */
$for WITH_REVERSE [[

static
THREADPOOL_FUNCTION(tppbspd$WITH_REVERSE)
#ifdef PRF_CORE_REPEAT
{
		char Header[1024]; 
		$if WITH_REVERSE [[
			unsigned char RevComp_Index_Mapping[ALPHABET_SIZE+2] __attribute__((aligned(16)));
		]]
		int res = SUCCESS;
// 	  printf("Thread started fct THREAD_FCT_NAME\n");
		
		/*************************************************************************/
    /*                          GET COMMON DATA                              */
    /*************************************************************************/
		common_t * const common = _Data->common;
		
		/* For profile search we need to have */
		const struct Profile * const restrict prf = common->profile;
		const Compute_t * const restrict CoreCompute =common->Compute;
		
		/* For output we need */
		const int ScoreRange[2] = { (common->OutputType)->ScoreRange[0],
																(common->OutputType)->ScoreRange[1] };
		const unsigned int CycleRange[2] = { (common->OutputType)->CycleRange[0], 
																				 (common->OutputType)->CycleRange[1] };

		const size_t HistogramBins = ScoreRange[1] - ScoreRange[0] + 1;
		const size_t Density_LD = CycleRange[1] - CycleRange[0] + 1;
		size_t * const restrict Histogram = common->Histograms + Density_LD*HistogramBins*_Data->threadID;
		
		/*************************************************************************/
		/*                          ALLOCATE MEMORY                              */
		/*************************************************************************/
		const size_t prfLength = prf->Length;
		const size_t matrixLD  = prf->Length + 1;
		size_t LargestSequence = 2048;
		union lScores * restrict matrix = _mm_malloc(matrixLD*LargestSequence*sizeof(union lScores), 64);
		$if WITH_REVERSE [[
			union lScores * restrict rvmatrix = _mm_malloc(matrixLD*LargestSequence*sizeof(union lScores), 64);
		]]
		unsigned char * restrict SequenceIndex = malloc(LargestSequence*sizeof(unsigned char));
		int * restrict WORK           = _mm_malloc(GetWorkArraySize(prf, CoreCompute),64);
		if ( $if WITH_REVERSE [[ rvmatrix == NULL || ]] matrix == NULL || WORK == NULL || SequenceIndex == NULL ) {
			res = -1; 
			goto FIN;
		}
				
		/*************************************************************************/
		/*                          CONFIGURE WORKER                             */
		/*************************************************************************/
		$if WITH_REVERSE [[
			for (unsigned char a=0;a<ALPHABET_SIZE+2; a++) RevComp_Index_Mapping[a] = a;
			{
				unsigned char c;
				c = RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'A' - (int) 'A' ] ];
				RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'A' - (int) 'A' ] ] = RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'T' - (int) 'A' ] ];
				RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'T' - (int) 'A' ] ] = c;
			}
			{
				unsigned char c;
				c = RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'C' - (int) 'A' ] ];
				RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'C' - (int) 'A' ] ] = RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'G' - (int) 'A' ] ];
				RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'G' - (int) 'A' ] ] = c;
			}
		]]

    /* Assure all threads have been created before starting serving */
    threadpool_t* const restrict  thpool = _Data->thpool;
   
//		/* Register signal handler */
//     struct sigaction act;
//     act.sa_handler = thread_hold;
//     if (sigaction(SIGUSR1, &act, NULL) == -1) {
// 	    fprintf(stderr, "thread_do(): cannot handle SIGUSR1");
//     }
    
    /* Mark thread as alive (initialized) */
    pthread_mutex_lock(&thpool->thcount_lock);
    thpool->num_threads_alive += 1;
    pthread_mutex_unlock(&thpool->thcount_lock);
    
    // Initialize some other data
    pb_job_t * task = NULL;
    size_t Missed = 0UL;
		
		while(thpool->threads_keepalive) {
			bsem_wait(thpool->jobqueue_p.has_items);
			
			if (thpool->threads_keepalive){
			    pthread_mutex_lock(&thpool->thcount_lock);
			    thpool->num_threads_working++;
			    pthread_mutex_unlock(&thpool->thcount_lock);
			    
			    /* Read job from queue and execute it */
			    pthread_mutex_lock(&thpool->jobqueue_p.rwmutex);
			    task = (pb_job_t*) jobqueue_pull(&thpool->jobqueue_p);
			    pthread_mutex_unlock(&thpool->jobqueue_p.rwmutex);
			    
			    /***************************************************************/
			    /*                     START THE TASK                          */
			    /***************************************************************/
			    if (task) {
						const HoleData_t * const HReg = &(task->HReg);
						const unsigned int HoleNumber = HReg->HoleNumber;
				    const unsigned int nRegions   = HReg->nRegions;
						restrictReadstoHQ(HReg);
						
						for (int i=0; i<nRegions; i++) {
							if (HReg->Regions[i].type == Insert) {
								const int lSeqLength = (int) HReg->Regions[i].stop - (int) HReg->Regions[i].start;
								if (lSeqLength <= 1) continue;
								PFSequence PFSeq = { .ProfileIndex=SequenceIndex , .Length = lSeqLength} ;

								if (PFSeq.Length >= LargestSequence) {
									_mm_free(matrix);
									$if WITH_REVERSE [[_mm_free(rvmatrix);]]
									LargestSequence = (PFSeq.Length + 1UL + 2047UL) & ~(2047UL);
									matrix        = _mm_malloc(matrixLD*LargestSequence*sizeof(union lScores), 64);
									$if WITH_REVERSE [[
										rvmatrix      = _mm_malloc(matrixLD*LargestSequence*sizeof(union lScores), 64);
									]]
									SequenceIndex = (unsigned char*) realloc(SequenceIndex, LargestSequence*sizeof(unsigned char));
									if ( $if WITH_REVERSE [[rvmatrix == NULL ||]] matrix == NULL || SequenceIndex == NULL) {
										res = -2; 
										goto FIN;
									}
									PFSeq.ProfileIndex = SequenceIndex;
								}
								const unsigned char * const restrict SequenceText = &(task->Reads.Stream[HReg->Regions[i].start]);
								
								/* Copy sequence to local space index */ 
								memcpy(PFSeq.ProfileIndex, SequenceText, PFSeq.Length);
								
								/* Translate into indices */
								TranslateSequenceToIndex(&PFSeq, prf->Alphabet_Mapping);
								
								/* Build matrix */
								CoreCompute->BuildMatrix(prf, PFSeq.ProfileIndex, matrix, WORK, NULL, 0, PFSeq.Length);
								
								$if WITH_REVERSE [[
									/* Reverse indices */
									RevCompIndex(&PFSeq, RevComp_Index_Mapping);
									
									/* Build reverse matrix */
									CoreCompute->BuildMatrix(prf, PFSeq.ProfileIndex, rvmatrix, WORK, NULL, 0, PFSeq.Length);
								]]
								
								/////////////////////////////////////////////////////////////////////////////////////////////////////////
								// WORK_ON_MATRICES;
								ScoreCycle_t SC $if WITH_REVERSE [[, rvSC]];
								GetBestScoreAndCycles(matrix, PFSeq.Length, prfLength, &SC);
								$if WITH_REVERSE [[
									GetBestScoreAndCycles(rvmatrix, PFSeq.Length, prfLength, &rvSC);
									int Score = (rvSC.Score > SC.Score) ? rvSC.Score : SC.Score;
									unsigned int Cycles = (rvSC.Score > SC.Score) ? rvSC.Cycles : SC.Cycles;
									if (Score>=ScoreRange[0] && Score<ScoreRange[1] && Cycles>=CycleRange[0] && Cycles<CycleRange[1]) {
										const size_t index = Score - ScoreRange[0];
										Histogram[index*Density_LD+Cycles-CycleRange[0] ]++;
									}
									else {
										Missed++;
									}
								]] $else [[
									if (SC.Score>=ScoreRange[0] && SC.Score<ScoreRange[1] && SC.Cycles>=CycleRange[0] && SC.Cycles<CycleRange[1]) {
										const size_t index = SC.Score - ScoreRange[0];
										Histogram[index*Density_LD+SC.Cycles-CycleRange[0] ]++;
									}
									else {
										Missed++;
									}
								]]
								
							}
						}
						
						/* Return the job memory slot */
						pthread_mutex_lock(&thpool->donequeue_p.rwmutex);
						jobqueue_push(&thpool->donequeue_p, (job_t*) task);
						pthread_mutex_unlock(&thpool->donequeue_p.rwmutex);
					}
			    pthread_mutex_lock(&thpool->thcount_lock);
			    thpool->num_threads_working--;
			    pthread_mutex_unlock(&thpool->thcount_lock);
			}
    }
    
    /////////////////////////////////////////////////////////////////////////////////////////////////////////
		//SUMMARIZE;
		common->Counters[_Data->threadID] = Missed;
     
    FIN:
    pthread_mutex_lock(&thpool->thcount_lock);
    thpool->num_threads_alive--;
    pthread_mutex_unlock(&thpool->thcount_lock);
		    
		if (WORK) _mm_free(WORK);
		if (matrix) _mm_free(matrix);
		$if WITH_REVERSE [[if (rvmatrix) _mm_free(rvmatrix);]]
		if (SequenceIndex) free(SequenceIndex);
	
    if( res != SUCCESS) {
      fprintf(stderr, "Thread %u error code %i\n", _Data->threadID, res);
      if (task) {
				pthread_mutex_lock(&thpool->thcount_lock);
				thpool->num_threads_working--;
				pthread_mutex_unlock(&thpool->thcount_lock);
      }
      thpool->threads_keepalive = 0;
    }
    
    _Data->returnState = (void*) (uintptr_t) res;
		
    return 0;
}
#else
{
	fputs("Enable PRF_CORE_REPEAT for cycles!\n", stderr);
	return (void*) 1;
}
#endif
]]


/****************************************************************************************************
 * MATRIX PROFILES: OTHER
 */
$for WITH_REVERSE [[

static
THREADPOOL_FUNCTION(tppbspo$WITH_REVERSE)
{
		char Header[1024]; 
		$if WITH_REVERSE [[
			unsigned char RevComp_Index_Mapping[ALPHABET_SIZE+2] __attribute__((aligned(16)));
		]]
		int res = SUCCESS;
// 	  printf("Thread started fct THREAD_FCT_NAME\n");
		
		/*************************************************************************/
    /*                          GET COMMON DATA                              */
    /*************************************************************************/
		common_t * const restrict common = _Data->common;
		
		/* For profile search we need to have */
		const struct Profile * const restrict prf = common->profile;
		const Compute_t * const restrict CoreCompute =common->Compute;
		
		/* For output we need */
		const OutputType_t * const restrict OutputType = common->OutputType;
		pthread_mutex_t * const restrict PrintLock = &(common->PrintLock);
		const void * const OutputMethodOptions = &((common->OutputType)->Specific);
		
		/*************************************************************************/
		/*                          ALLOCATE MEMORY                              */
		/*************************************************************************/
		const size_t prfLength = prf->Length;
		const size_t matrixLD  = prf->Length + 1;
		size_t LargestSequence = 2048;
		union lScores * restrict matrix = _mm_malloc(matrixLD*LargestSequence*sizeof(union lScores), 64);
		$if WITH_REVERSE [[
			union lScores * restrict rvmatrix = _mm_malloc(matrixLD*LargestSequence*sizeof(union lScores), 64);
		]]
		unsigned char * restrict SequenceIndex = malloc(LargestSequence*sizeof(unsigned char));
		int * restrict WORK          = _mm_malloc(GetWorkArraySize(prf, CoreCompute),64);
		if ( $if WITH_REVERSE [[ rvmatrix == NULL || ]] matrix == NULL || WORK == NULL || SequenceIndex == NULL ) {
			res = -1; 
			goto FIN;
		}
				
		/*************************************************************************/
		/*                          CONFIGURE WORKER                             */
		/*************************************************************************/
		$if WITH_REVERSE [[
			for (unsigned char a=0;a<ALPHABET_SIZE+2; a++) RevComp_Index_Mapping[a] = a;
			{
				unsigned char c;
				c = RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'A' - (int) 'A' ] ];
				RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'A' - (int) 'A' ] ] = RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'T' - (int) 'A' ] ];
				RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'T' - (int) 'A' ] ] = c;
			}
			{
				unsigned char c;
				c = RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'C' - (int) 'A' ] ];
				RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'C' - (int) 'A' ] ] = RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'G' - (int) 'A' ] ];
				RevComp_Index_Mapping[prf->Alphabet_Mapping[(int) 'G' - (int) 'A' ] ] = c;
			}
		]]

    /* Assure all threads have been created before starting serving */
    threadpool_t* const restrict  thpool = _Data->thpool;
   
//		/* Register signal handler */
//     struct sigaction act;
//     act.sa_handler = thread_hold;
//     if (sigaction(SIGUSR1, &act, NULL) == -1) {
// 	    fprintf(stderr, "thread_do(): cannot handle SIGUSR1");
//     }
    
    /* Mark thread as alive (initialized) */
    pthread_mutex_lock(&thpool->thcount_lock);
    thpool->num_threads_alive += 1;
    pthread_mutex_unlock(&thpool->thcount_lock);
    
    // Initialize some other data
    pb_job_t * task = NULL;
		
    const int CutOff = prf->CutOff;
		
		while(thpool->threads_keepalive) {
			bsem_wait(thpool->jobqueue_p.has_items);
			
			if (thpool->threads_keepalive){
			    pthread_mutex_lock(&thpool->thcount_lock);
			    thpool->num_threads_working++;
			    pthread_mutex_unlock(&thpool->thcount_lock);
			    
			    /* Read job from queue and execute it */
			    pthread_mutex_lock(&thpool->jobqueue_p.rwmutex);
			    task = (pb_job_t*) jobqueue_pull(&thpool->jobqueue_p);
			    pthread_mutex_unlock(&thpool->jobqueue_p.rwmutex);
			    
			    /***************************************************************/
			    /*                     START THE TASK                          */
			    /***************************************************************/
			    if (task) {
						const HoleData_t * const HReg = &(task->HReg);
						const unsigned int HoleNumber = HReg->HoleNumber;
				    const unsigned int nRegions   = HReg->nRegions;
// 						printf("Thread %lu working on hole %u, %u regions found\n", ((ThreadPool_Arg_t*)_Data)->ID, HoleNumber, nRegions);
						restrictReadstoHQ(HReg);
						
						for (int i=0; i<nRegions; i++) {
							if (HReg->Regions[i].type == Insert) {
								const int lSeqLength = (int) HReg->Regions[i].stop - (int) HReg->Regions[i].start;
								if (lSeqLength <= 1) continue;
								PFSequence PFSeq = { .ProfileIndex=SequenceIndex , .Length = lSeqLength} ;
// 								printf("%.*s\n", (int) PFSeq.Length, &(task->Reads.Stream[HReg->Regions[i].start]));
// 								goto FIN;
								if (PFSeq.Length >= LargestSequence) {
									_mm_free(matrix);
									$if WITH_REVERSE [[_mm_free(rvmatrix);]]
									LargestSequence = (PFSeq.Length + 1UL + 2047UL) & ~(2047UL);
									matrix        = _mm_malloc(matrixLD*LargestSequence*sizeof(union lScores), 64);
									$if WITH_REVERSE [[
									rvmatrix      = _mm_malloc(matrixLD*LargestSequence*sizeof(union lScores), 64);
									]]
									SequenceIndex = (unsigned char*) realloc(SequenceIndex, LargestSequence*sizeof(unsigned char));
									if ( $if WITH_REVERSE [[rvmatrix == NULL ||]] matrix == NULL || SequenceIndex == NULL) {
										res = -2; 
										goto FIN;
									}
									PFSeq.ProfileIndex = SequenceIndex;
								}
								unsigned char * const restrict SequenceText = &(task->Reads.Stream[HReg->Regions[i].start]);
								
								/* Copy sequence to local space index */ 
								memcpy(PFSeq.ProfileIndex, SequenceText, PFSeq.Length);
								
								/* Translate into indices */
								TranslateSequenceToIndex(&PFSeq, prf->Alphabet_Mapping);
								
								/* Build matrix */
								CoreCompute->BuildMatrix(prf, PFSeq.ProfileIndex, matrix, WORK, NULL, 0, PFSeq.Length);
								
								$if WITH_REVERSE [[
									/* Reverse indices */
									RevCompIndex(&PFSeq, RevComp_Index_Mapping);
									
									/* Build reverse matrix */
									CoreCompute->BuildMatrix(prf, PFSeq.ProfileIndex, rvmatrix, WORK, NULL, 0, PFSeq.Length);
								]]
								
								///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								snprintf(Header, 1024,"ZMW_%u_%i/%u-%u", HoleNumber, i, HReg->Regions[i].start, HReg->Regions[i].stop);
								OutputType->OutputFct(matrix, $if WITH_REVERSE [[ rvmatrix ]] $else [[ NULL ]], SequenceText, Header,
						       prf, CoreCompute, PFSeq.Length, OutputMethodOptions, PrintLock);
							}
						}
						
						/* Return the job memory slot */
						pthread_mutex_lock(&thpool->donequeue_p.rwmutex);
						jobqueue_push(&thpool->donequeue_p, (job_t*) task);
						pthread_mutex_unlock(&thpool->donequeue_p.rwmutex);
					}
			    pthread_mutex_lock(&thpool->thcount_lock);
			    thpool->num_threads_working--;
			    pthread_mutex_unlock(&thpool->thcount_lock);
			}
    }
         
    FIN:
    pthread_mutex_lock(&thpool->thcount_lock);
    thpool->num_threads_alive--;
    pthread_mutex_unlock(&thpool->thcount_lock);
		    
		if (WORK) _mm_free(WORK);
		if (matrix) _mm_free(matrix);
		$if WITH_REVERSE [[if (rvmatrix) _mm_free(rvmatrix);]]
		if (SequenceIndex) free(SequenceIndex);
		
    if( res != SUCCESS) {
      fprintf(stderr, "Thread %u error code %i\n", _Data->threadID, res);
      if (task) {
				pthread_mutex_lock(&thpool->thcount_lock);
				thpool->num_threads_working--;
				pthread_mutex_unlock(&thpool->thcount_lock);
      }
      thpool->threads_keepalive = 0;
    }
    
    _Data->returnState = (void*) (uintptr_t) res;
		
    return 0;
}

]]


THREADPOOL_FUNCTION( (*ltp_pbsp[]) ) = {
$for WRAPPER_TEXT [[
$for BORDER_CLIP [[ $for INVERSE_SELECTION [[ $for CYCLE_RANGE [[ $for SCORE_RANGE [[ $for WITH_REVERSE [[
$if ((WRAPPER_TEXT < 5) | WITH_REVERSE) [[ 
	&tppbsps$WRAPPER_TEXT$BORDER_CLIP$INVERSE_SELECTION$CYCLE_RANGE$SCORE_RANGE$WITH_REVERSE,
]]
]] ]] ]] ]] ]]
]]

$for HISTO_CYCLE [[
$for CYCLE_RANGE [[ $for SCORE_RANGE [[ $for BORDER_CLIP [[ $for WITH_REVERSE [[
$if ((SCORE_RANGE & ~(HISTO_CYCLE)) | (HISTO_CYCLE & CYCLE_RANGE)) [[
	&tppbsph$HISTO_CYCLE$BORDER_CLIP$CYCLE_RANGE$SCORE_RANGE$WITH_REVERSE,

]]
]] ]] ]] ]]
]]


$for WITH_REVERSE [[
	&tppbspd$WITH_REVERSE,
]]


$for WITH_REVERSE [[
	&tppbspo$WITH_REVERSE,
]]

	0
};

THREADPOOL_FUNCTION( (* * tp_pbsp) ) = ltp_pbsp;

THREADPOOL_FUNCTION(tp_pb_filtertest)
{
		int res = SUCCESS;
		char Buffer[64*1024];
		
		/*************************************************************************/
    /*                          GET COMMON DATA                              */
    /*************************************************************************/
		common_t * const common = _Data->common;
		pthread_mutex_t * const restrict PrintLock = &(common->PrintLock);
		
		/*************************************************************************/
    /*                          ALLOCATE MEMORY                              */
    /*************************************************************************/

		/*************************************************************************/
    /*                          CONFIGURE WORKER                             */
    /*************************************************************************/
    
    /* Assure all threads have been created before starting serving */
    threadpool_t* const restrict  thpool = _Data->thpool;
   
    /* Register signal handler */
//     struct sigaction act;
//     act.sa_handler = thread_hold;
//     if (sigaction(SIGUSR1, &act, NULL) == -1) {
// 	    fprintf(stderr, "thread_do(): cannot handle SIGUSR1");
//     }
    
    /* Mark thread as alive (initialized) */
    pthread_mutex_lock(&thpool->thcount_lock);
    thpool->num_threads_alive += 1;
    pthread_mutex_unlock(&thpool->thcount_lock);
    
    // Initialize some other data
    pb_job_t * task = NULL;
		
		while(thpool->threads_keepalive) {
			bsem_wait(thpool->jobqueue_p.has_items);
			
			if (thpool->threads_keepalive){
			    pthread_mutex_lock(&thpool->thcount_lock);
			    thpool->num_threads_working++;
			    pthread_mutex_unlock(&thpool->thcount_lock);
			    
			    /* Read job from queue and execute it */
			    pthread_mutex_lock(&thpool->jobqueue_p.rwmutex);
			    task = (pb_job_t*) jobqueue_pull(&thpool->jobqueue_p);
			    pthread_mutex_unlock(&thpool->jobqueue_p.rwmutex);
			    
			    /***************************************************************/
			    /*                     START THE TASK                          */
			    /***************************************************************/
			    if (task) {
						const HoleData_t * const HReg = &(task->HReg);
						const unsigned int HoleNumber = HReg->HoleNumber;
				    const unsigned int nRegions   = HReg->nRegions;
						char * ptr = Buffer;
 						int count = snprintf(ptr, 64*1024, "ZMW %u, %u regions found\n", HoleNumber, nRegions);
						ptr += count;
	//					restrictReadstoHQ(HReg);
						
						const HoleRegion_t * Regions = HReg->Regions; 
						for (unsigned int i=0; i<nRegions; i++) {
							assert(count<64*1024);
							const int move = snprintf(ptr, (size_t) (64*1024-count), "\t- %s\t[%i,%i]\t%i\n", 
															  RegionTypeName[Regions->type], Regions->start, Regions->stop, Regions->quality);
							ptr += move;
							count += move;
							Regions++;
						}
						
						pthread_mutex_lock(PrintLock);
						printf("%s\n", Buffer);
						pthread_mutex_unlock(PrintLock);
						
						/* Return the job memory slot */
						pthread_mutex_lock(&thpool->donequeue_p.rwmutex);
						jobqueue_push(&thpool->donequeue_p, (job_t*) task);
						pthread_mutex_unlock(&thpool->donequeue_p.rwmutex);
					}
			    pthread_mutex_lock(&thpool->thcount_lock);
			    thpool->num_threads_working--;
			    pthread_mutex_unlock(&thpool->thcount_lock);
			}
    }
     
    FIN:
    pthread_mutex_lock(&thpool->thcount_lock);
    thpool->num_threads_alive--;
    pthread_mutex_unlock(&thpool->thcount_lock);
		    		
    if( res != SUCCESS) {
      fprintf(stderr, "Thread %u error code %i\n", _Data->threadID, res);
      if (task) {
				pthread_mutex_lock(&thpool->thcount_lock);
				thpool->num_threads_working--;
				pthread_mutex_unlock(&thpool->thcount_lock);
      }
      thpool->threads_keepalive = 0;
    }
    
    _Data->returnState = (void*) (uintptr_t) res;
		
    return 0;
}
